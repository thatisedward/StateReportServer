//
// This file war generated by FastJce2go 1.0
// Generated from Proxy.jce
// Tencent.

package DCache

import (
	"fmt"
	"tars"
	m "tars/model"
	"tars/protocol/codec"
	"tars/protocol/res/requestf"
)

type Proxy struct {
	s m.Servant
}

func (_obj *Proxy) GetString(ModuleName string, KeyItem string, Value *string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(KeyItem, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "getString", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_string(&(*Value), 3, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) GetInt(ModuleName string, KeyItem int32, Value *string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(KeyItem, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "getInt", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_string(&(*Value), 3, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) GetLong(ModuleName string, KeyItem int64, Value *string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int64(KeyItem, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "getLong", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_string(&(*Value), 3, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) GetStringWithVer(ModuleName string, KeyItem string, Value *string, Ver *int8, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(KeyItem, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "getStringWithVer", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_string(&(*Value), 3, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int8(&(*Ver), 4, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) GetIntWithVer(ModuleName string, KeyItem int32, Value *string, Ver *int8, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(KeyItem, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "getIntWithVer", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_string(&(*Value), 3, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int8(&(*Ver), 4, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) GetLongWithVer(ModuleName string, KeyItem int64, Value *string, Ver *int8, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int64(KeyItem, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "getLongWithVer", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_string(&(*Value), 3, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int8(&(*Ver), 4, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) GetStringBS(ModuleName string, KeyItem []int8, Value *[]int8, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(KeyItem)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(KeyItem)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "getStringBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(3, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*Value) = make([]int8, length, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = _is.Read_int8(&(*Value)[i0], 0, false)
			if err != nil {
				return ret, err
			}
		}
	} else if ty == codec.SIMPLE_LIST {

		err, _ = _is.SkipTo(codec.BYTE, 0, true)
		if err != nil {
			return ret, err
		}
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		err = _is.Read_slice_int8(&(*Value), length, true)
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) GetIntBS(ModuleName string, KeyItem int32, Value *[]int8, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(KeyItem, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "getIntBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(3, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*Value) = make([]int8, length, length)
		for i1, e1 := int32(0), length; i1 < e1; i1++ {

			err = _is.Read_int8(&(*Value)[i1], 0, false)
			if err != nil {
				return ret, err
			}
		}
	} else if ty == codec.SIMPLE_LIST {

		err, _ = _is.SkipTo(codec.BYTE, 0, true)
		if err != nil {
			return ret, err
		}
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		err = _is.Read_slice_int8(&(*Value), length, true)
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) GetLongBS(ModuleName string, KeyItem int64, Value *[]int8, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int64(KeyItem, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "getLongBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(3, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*Value) = make([]int8, length, length)
		for i2, e2 := int32(0), length; i2 < e2; i2++ {

			err = _is.Read_int8(&(*Value)[i2], 0, false)
			if err != nil {
				return ret, err
			}
		}
	} else if ty == codec.SIMPLE_LIST {

		err, _ = _is.SkipTo(codec.BYTE, 0, true)
		if err != nil {
			return ret, err
		}
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		err = _is.Read_slice_int8(&(*Value), length, true)
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) GetStringWithVerBS(ModuleName string, KeyItem []int8, Value *[]int8, Ver *int8, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(KeyItem)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(KeyItem)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "getStringWithVerBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(3, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*Value) = make([]int8, length, length)
		for i3, e3 := int32(0), length; i3 < e3; i3++ {

			err = _is.Read_int8(&(*Value)[i3], 0, false)
			if err != nil {
				return ret, err
			}
		}
	} else if ty == codec.SIMPLE_LIST {

		err, _ = _is.SkipTo(codec.BYTE, 0, true)
		if err != nil {
			return ret, err
		}
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		err = _is.Read_slice_int8(&(*Value), length, true)
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	err = _is.Read_int8(&(*Ver), 4, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) GetIntWithVerBS(ModuleName string, KeyItem int32, Value *[]int8, Ver *int8, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(KeyItem, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "getIntWithVerBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(3, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*Value) = make([]int8, length, length)
		for i4, e4 := int32(0), length; i4 < e4; i4++ {

			err = _is.Read_int8(&(*Value)[i4], 0, false)
			if err != nil {
				return ret, err
			}
		}
	} else if ty == codec.SIMPLE_LIST {

		err, _ = _is.SkipTo(codec.BYTE, 0, true)
		if err != nil {
			return ret, err
		}
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		err = _is.Read_slice_int8(&(*Value), length, true)
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	err = _is.Read_int8(&(*Ver), 4, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) GetLongWithVerBS(ModuleName string, KeyItem int64, Value *[]int8, Ver *int8, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int64(KeyItem, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "getLongWithVerBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(3, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*Value) = make([]int8, length, length)
		for i5, e5 := int32(0), length; i5 < e5; i5++ {

			err = _is.Read_int8(&(*Value)[i5], 0, false)
			if err != nil {
				return ret, err
			}
		}
	} else if ty == codec.SIMPLE_LIST {

		err, _ = _is.SkipTo(codec.BYTE, 0, true)
		if err != nil {
			return ret, err
		}
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		err = _is.Read_slice_int8(&(*Value), length, true)
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	err = _is.Read_int8(&(*Ver), 4, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) GetStringBatch(ModuleName string, VtKeyItem []string, VtValue *[]SKeyValue, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtKeyItem)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtKeyItem {

		err = _os.Write_string(v, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "getStringBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(3, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*VtValue) = make([]SKeyValue, length, length)
		for i6, e6 := int32(0), length; i6 < e6; i6++ {

			err = (*VtValue)[i6].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}
		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("type not support SIMPLE_LIST.")
		if err != nil {
			return ret, err
		}
	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) GetIntBatch(ModuleName string, VtKeyItem []int32, VtValue *[]IKeyValue, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtKeyItem)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtKeyItem {

		err = _os.Write_int32(v, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "getIntBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(3, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*VtValue) = make([]IKeyValue, length, length)
		for i7, e7 := int32(0), length; i7 < e7; i7++ {

			err = (*VtValue)[i7].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}
		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("type not support SIMPLE_LIST.")
		if err != nil {
			return ret, err
		}
	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) GetLongBatch(ModuleName string, VtKeyItem []int64, VtValue *[]LKeyValue, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtKeyItem)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtKeyItem {

		err = _os.Write_int64(v, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "getLongBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(3, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*VtValue) = make([]LKeyValue, length, length)
		for i8, e8 := int32(0), length; i8 < e8; i8++ {

			err = (*VtValue)[i8].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}
		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("type not support SIMPLE_LIST.")
		if err != nil {
			return ret, err
		}
	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) GetStringBatchBS(ModuleName string, VtKeyItem [][]int8, VtValue *[]SKeyValueBS, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtKeyItem)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtKeyItem {

		err = _os.WriteHead(codec.SIMPLE_LIST, 0)
		if err != nil {
			return ret, err
		}
		err = _os.WriteHead(codec.BYTE, 0)
		if err != nil {
			return ret, err
		}
		err = _os.Write_int32(int32(len(v)), 0)
		if err != nil {
			return ret, err
		}
		err = _os.Write_slice_int8(v)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "getStringBatchBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(3, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*VtValue) = make([]SKeyValueBS, length, length)
		for i9, e9 := int32(0), length; i9 < e9; i9++ {

			err = (*VtValue)[i9].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}
		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("type not support SIMPLE_LIST.")
		if err != nil {
			return ret, err
		}
	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) GetIntBatchBS(ModuleName string, VtKeyItem []int32, VtValue *[]IKeyValueBS, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtKeyItem)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtKeyItem {

		err = _os.Write_int32(v, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "getIntBatchBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(3, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*VtValue) = make([]IKeyValueBS, length, length)
		for i10, e10 := int32(0), length; i10 < e10; i10++ {

			err = (*VtValue)[i10].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}
		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("type not support SIMPLE_LIST.")
		if err != nil {
			return ret, err
		}
	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) GetLongBatchBS(ModuleName string, VtKeyItem []int64, VtValue *[]LKeyValueBS, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtKeyItem)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtKeyItem {

		err = _os.Write_int64(v, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "getLongBatchBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(3, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*VtValue) = make([]LKeyValueBS, length, length)
		for i11, e11 := int32(0), length; i11 < e11; i11++ {

			err = (*VtValue)[i11].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}
		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("type not support SIMPLE_LIST.")
		if err != nil {
			return ret, err
		}
	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) CheckString(ModuleName string, KeyItem string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(KeyItem, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "checkString", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) CheckInt(ModuleName string, KeyItem int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(KeyItem, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "checkInt", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) CheckLong(ModuleName string, KeyItem int64, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int64(KeyItem, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "checkLong", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) CheckStringBatch(ModuleName string, VtKeyItem []string, MpResult *map[string]int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtKeyItem)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtKeyItem {

		err = _os.Write_string(v, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "checkStringBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have = _is.SkipTo(codec.MAP, 3, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&length, 0, true)
	if err != nil {
		return ret, err
	}
	(*MpResult) = make(map[string]int32)
	for i12, e12 := int32(0), length; i12 < e12; i12++ {
		var k12 string
		var v12 int32

		err = _is.Read_string(&k12, 0, false)
		if err != nil {
			return ret, err
		}

		err = _is.Read_int32(&v12, 1, false)
		if err != nil {
			return ret, err
		}

		(*MpResult)[k12] = v12
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) CheckIntBatch(ModuleName string, VtKeyItem []int32, MpResult *map[int32]int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtKeyItem)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtKeyItem {

		err = _os.Write_int32(v, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "checkIntBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have = _is.SkipTo(codec.MAP, 3, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&length, 0, true)
	if err != nil {
		return ret, err
	}
	(*MpResult) = make(map[int32]int32)
	for i13, e13 := int32(0), length; i13 < e13; i13++ {
		var k13 int32
		var v13 int32

		err = _is.Read_int32(&k13, 0, false)
		if err != nil {
			return ret, err
		}

		err = _is.Read_int32(&v13, 1, false)
		if err != nil {
			return ret, err
		}

		(*MpResult)[k13] = v13
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) CheckLongBatch(ModuleName string, VtKeyItem []int64, MpResult *map[int64]int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtKeyItem)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtKeyItem {

		err = _os.Write_int64(v, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "checkLongBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have = _is.SkipTo(codec.MAP, 3, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&length, 0, true)
	if err != nil {
		return ret, err
	}
	(*MpResult) = make(map[int64]int32)
	for i14, e14 := int32(0), length; i14 < e14; i14++ {
		var k14 int64
		var v14 int32

		err = _is.Read_int64(&k14, 0, false)
		if err != nil {
			return ret, err
		}

		err = _is.Read_int32(&v14, 1, false)
		if err != nil {
			return ret, err
		}

		(*MpResult)[k14] = v14
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) CheckStringBatchBS(ModuleName string, VtKeyItem [][]int8, MpResult *map[string]int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtKeyItem)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtKeyItem {

		err = _os.WriteHead(codec.SIMPLE_LIST, 0)
		if err != nil {
			return ret, err
		}
		err = _os.WriteHead(codec.BYTE, 0)
		if err != nil {
			return ret, err
		}
		err = _os.Write_int32(int32(len(v)), 0)
		if err != nil {
			return ret, err
		}
		err = _os.Write_slice_int8(v)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "checkStringBatchBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have = _is.SkipTo(codec.MAP, 3, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&length, 0, true)
	if err != nil {
		return ret, err
	}
	(*MpResult) = make(map[string]int32)
	for i15, e15 := int32(0), length; i15 < e15; i15++ {
		var k15 string
		var v15 int32

		err = _is.Read_string(&k15, 0, false)
		if err != nil {
			return ret, err
		}

		err = _is.Read_int32(&v15, 1, false)
		if err != nil {
			return ret, err
		}

		(*MpResult)[k15] = v15
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) CheckIntBatchBS(ModuleName string, VtKeyItem []int32, MpResult *map[int32]int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtKeyItem)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtKeyItem {

		err = _os.Write_int32(v, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "checkIntBatchBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have = _is.SkipTo(codec.MAP, 3, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&length, 0, true)
	if err != nil {
		return ret, err
	}
	(*MpResult) = make(map[int32]int32)
	for i16, e16 := int32(0), length; i16 < e16; i16++ {
		var k16 int32
		var v16 int32

		err = _is.Read_int32(&k16, 0, false)
		if err != nil {
			return ret, err
		}

		err = _is.Read_int32(&v16, 1, false)
		if err != nil {
			return ret, err
		}

		(*MpResult)[k16] = v16
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) CheckLongBatchBS(ModuleName string, VtKeyItem []int64, MpResult *map[int64]int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtKeyItem)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtKeyItem {

		err = _os.Write_int64(v, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "checkLongBatchBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have = _is.SkipTo(codec.MAP, 3, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&length, 0, true)
	if err != nil {
		return ret, err
	}
	(*MpResult) = make(map[int64]int32)
	for i17, e17 := int32(0), length; i17 < e17; i17++ {
		var k17 int64
		var v17 int32

		err = _is.Read_int64(&k17, 0, false)
		if err != nil {
			return ret, err
		}

		err = _is.Read_int32(&v17, 1, false)
		if err != nil {
			return ret, err
		}

		(*MpResult)[k17] = v17
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SetString(ModuleName string, KeyItem string, Value string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(KeyItem, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Value, 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "setString", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SetInt(ModuleName string, KeyItem int32, Value string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(KeyItem, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Value, 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "setInt", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SetLong(ModuleName string, KeyItem int64, Value string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int64(KeyItem, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Value, 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "setLong", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SetStringBS(ModuleName string, KeyItem []int8, Value []int8, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(KeyItem)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(KeyItem)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 3)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(Value)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(Value)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "setStringBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SetIntBS(ModuleName string, KeyItem int32, Value []int8, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(KeyItem, 2)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 3)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(Value)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(Value)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "setIntBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SetLongBS(ModuleName string, KeyItem int64, Value []int8, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int64(KeyItem, 2)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 3)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(Value)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(Value)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "setLongBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SetIntBatch(ModuleName string, KeyValue map[int32]string, KeyResult *map[int32]int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.MAP, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(KeyValue)), 0)
	if err != nil {
		return ret, err
	}
	for k18, v18 := range KeyValue {

		err = _os.Write_int32(k18, 0)
		if err != nil {
			return ret, err
		}

		err = _os.Write_string(v18, 1)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "setIntBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have = _is.SkipTo(codec.MAP, 3, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&length, 0, true)
	if err != nil {
		return ret, err
	}
	(*KeyResult) = make(map[int32]int32)
	for i19, e19 := int32(0), length; i19 < e19; i19++ {
		var k19 int32
		var v19 int32

		err = _is.Read_int32(&k19, 0, false)
		if err != nil {
			return ret, err
		}

		err = _is.Read_int32(&v19, 1, false)
		if err != nil {
			return ret, err
		}

		(*KeyResult)[k19] = v19
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SetLongBatch(ModuleName string, KeyValue map[int64]string, KeyResult *map[int64]int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.MAP, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(KeyValue)), 0)
	if err != nil {
		return ret, err
	}
	for k20, v20 := range KeyValue {

		err = _os.Write_int64(k20, 0)
		if err != nil {
			return ret, err
		}

		err = _os.Write_string(v20, 1)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "setLongBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have = _is.SkipTo(codec.MAP, 3, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&length, 0, true)
	if err != nil {
		return ret, err
	}
	(*KeyResult) = make(map[int64]int32)
	for i21, e21 := int32(0), length; i21 < e21; i21++ {
		var k21 int64
		var v21 int32

		err = _is.Read_int64(&k21, 0, false)
		if err != nil {
			return ret, err
		}

		err = _is.Read_int32(&v21, 1, false)
		if err != nil {
			return ret, err
		}

		(*KeyResult)[k21] = v21
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SetStringBatch(ModuleName string, KeyValue map[string]string, KeyResult *map[string]int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.MAP, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(KeyValue)), 0)
	if err != nil {
		return ret, err
	}
	for k22, v22 := range KeyValue {

		err = _os.Write_string(k22, 0)
		if err != nil {
			return ret, err
		}

		err = _os.Write_string(v22, 1)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "setStringBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have = _is.SkipTo(codec.MAP, 3, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&length, 0, true)
	if err != nil {
		return ret, err
	}
	(*KeyResult) = make(map[string]int32)
	for i23, e23 := int32(0), length; i23 < e23; i23++ {
		var k23 string
		var v23 int32

		err = _is.Read_string(&k23, 0, false)
		if err != nil {
			return ret, err
		}

		err = _is.Read_int32(&v23, 1, false)
		if err != nil {
			return ret, err
		}

		(*KeyResult)[k23] = v23
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SetIntBatchBS(ModuleName string, KeyValue map[int32][]int8, KeyResult *map[int32]int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.MAP, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(KeyValue)), 0)
	if err != nil {
		return ret, err
	}
	for k24, v24 := range KeyValue {

		err = _os.Write_int32(k24, 0)
		if err != nil {
			return ret, err
		}

		err = _os.WriteHead(codec.SIMPLE_LIST, 1)
		if err != nil {
			return ret, err
		}
		err = _os.WriteHead(codec.BYTE, 0)
		if err != nil {
			return ret, err
		}
		err = _os.Write_int32(int32(len(v24)), 0)
		if err != nil {
			return ret, err
		}
		err = _os.Write_slice_int8(v24)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "setIntBatchBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have = _is.SkipTo(codec.MAP, 3, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&length, 0, true)
	if err != nil {
		return ret, err
	}
	(*KeyResult) = make(map[int32]int32)
	for i25, e25 := int32(0), length; i25 < e25; i25++ {
		var k25 int32
		var v25 int32

		err = _is.Read_int32(&k25, 0, false)
		if err != nil {
			return ret, err
		}

		err = _is.Read_int32(&v25, 1, false)
		if err != nil {
			return ret, err
		}

		(*KeyResult)[k25] = v25
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SetLongBatchBS(ModuleName string, KeyValue map[int64][]int8, KeyResult *map[int64]int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.MAP, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(KeyValue)), 0)
	if err != nil {
		return ret, err
	}
	for k26, v26 := range KeyValue {

		err = _os.Write_int64(k26, 0)
		if err != nil {
			return ret, err
		}

		err = _os.WriteHead(codec.SIMPLE_LIST, 1)
		if err != nil {
			return ret, err
		}
		err = _os.WriteHead(codec.BYTE, 0)
		if err != nil {
			return ret, err
		}
		err = _os.Write_int32(int32(len(v26)), 0)
		if err != nil {
			return ret, err
		}
		err = _os.Write_slice_int8(v26)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "setLongBatchBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have = _is.SkipTo(codec.MAP, 3, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&length, 0, true)
	if err != nil {
		return ret, err
	}
	(*KeyResult) = make(map[int64]int32)
	for i27, e27 := int32(0), length; i27 < e27; i27++ {
		var k27 int64
		var v27 int32

		err = _is.Read_int64(&k27, 0, false)
		if err != nil {
			return ret, err
		}

		err = _is.Read_int32(&v27, 1, false)
		if err != nil {
			return ret, err
		}

		(*KeyResult)[k27] = v27
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SetStringBatchBS(ModuleName string, KeyValue []SSetKeyValueBS, KeyResult *[]SSetKeyResultBS, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(KeyValue)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range KeyValue {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "setStringBatchBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(3, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*KeyResult) = make([]SSetKeyResultBS, length, length)
		for i28, e28 := int32(0), length; i28 < e28; i28++ {

			err = (*KeyResult)[i28].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}
		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("type not support SIMPLE_LIST.")
		if err != nil {
			return ret, err
		}
	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SetStringWithDirty(ModuleName string, KeyItem string, Value string, Dirty bool, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(KeyItem, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Value, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool(Dirty, 4)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "setStringWithDirty", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SetIntWithDirty(ModuleName string, KeyItem int32, Value string, Dirty bool, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(KeyItem, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Value, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool(Dirty, 4)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "setIntWithDirty", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SetLongWithDirty(ModuleName string, KeyItem int64, Value string, Dirty bool, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int64(KeyItem, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Value, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool(Dirty, 4)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "setLongWithDirty", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SetStringWithDirtyBS(ModuleName string, KeyItem []int8, Value []int8, Dirty bool, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(KeyItem)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(KeyItem)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 3)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(Value)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(Value)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool(Dirty, 4)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "setStringWithDirtyBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SetIntWithDirtyBS(ModuleName string, KeyItem int32, Value []int8, Dirty bool, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(KeyItem, 2)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 3)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(Value)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(Value)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool(Dirty, 4)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "setIntWithDirtyBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SetLongWithDirtyBS(ModuleName string, KeyItem int64, Value []int8, Dirty bool, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int64(KeyItem, 2)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 3)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(Value)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(Value)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool(Dirty, 4)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "setLongWithDirtyBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SetStringEx(ModuleName string, KeyItem string, Value string, Ver int8, Dirty bool, ExpireTimeSecond int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(KeyItem, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Value, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int8(Ver, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool(Dirty, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(ExpireTimeSecond, 6)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "setStringEx", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SetIntEx(ModuleName string, KeyItem int32, Value string, Ver int8, Dirty bool, ExpireTimeSecond int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(KeyItem, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Value, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int8(Ver, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool(Dirty, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(ExpireTimeSecond, 6)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "setIntEx", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SetLongEx(ModuleName string, KeyItem int64, Value string, Ver int8, Dirty bool, ExpireTimeSecond int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int64(KeyItem, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Value, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int8(Ver, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool(Dirty, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(ExpireTimeSecond, 6)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "setLongEx", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SetStringExBS(ModuleName string, KeyItem []int8, Value []int8, Ver int8, Dirty bool, ExpireTimeSecond int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(KeyItem)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(KeyItem)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 3)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(Value)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(Value)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int8(Ver, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool(Dirty, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(ExpireTimeSecond, 6)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "setStringExBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SetIntExBS(ModuleName string, KeyItem int32, Value []int8, Ver int8, Dirty bool, ExpireTimeSecond int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(KeyItem, 2)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 3)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(Value)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(Value)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int8(Ver, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool(Dirty, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(ExpireTimeSecond, 6)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "setIntExBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SetLongExBS(ModuleName string, KeyItem int64, Value []int8, Ver int8, Dirty bool, ExpireTimeSecond int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int64(KeyItem, 2)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 3)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(Value)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(Value)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int8(Ver, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool(Dirty, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(ExpireTimeSecond, 6)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "setLongExBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SetStringExBatch(ModuleName string, KeyValue []SSetKeyValue, KeyResult *map[string]int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(KeyValue)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range KeyValue {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "setStringExBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have = _is.SkipTo(codec.MAP, 3, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&length, 0, true)
	if err != nil {
		return ret, err
	}
	(*KeyResult) = make(map[string]int32)
	for i29, e29 := int32(0), length; i29 < e29; i29++ {
		var k29 string
		var v29 int32

		err = _is.Read_string(&k29, 0, false)
		if err != nil {
			return ret, err
		}

		err = _is.Read_int32(&v29, 1, false)
		if err != nil {
			return ret, err
		}

		(*KeyResult)[k29] = v29
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SetIntExBatch(ModuleName string, KeyValue []ISetKeyValue, KeyResult *map[int32]int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(KeyValue)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range KeyValue {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "setIntExBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have = _is.SkipTo(codec.MAP, 3, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&length, 0, true)
	if err != nil {
		return ret, err
	}
	(*KeyResult) = make(map[int32]int32)
	for i30, e30 := int32(0), length; i30 < e30; i30++ {
		var k30 int32
		var v30 int32

		err = _is.Read_int32(&k30, 0, false)
		if err != nil {
			return ret, err
		}

		err = _is.Read_int32(&v30, 1, false)
		if err != nil {
			return ret, err
		}

		(*KeyResult)[k30] = v30
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SetLongExBatch(ModuleName string, KeyValue []LSetKeyValue, KeyResult *map[int64]int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(KeyValue)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range KeyValue {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "setLongExBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have = _is.SkipTo(codec.MAP, 3, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&length, 0, true)
	if err != nil {
		return ret, err
	}
	(*KeyResult) = make(map[int64]int32)
	for i31, e31 := int32(0), length; i31 < e31; i31++ {
		var k31 int64
		var v31 int32

		err = _is.Read_int64(&k31, 0, false)
		if err != nil {
			return ret, err
		}

		err = _is.Read_int32(&v31, 1, false)
		if err != nil {
			return ret, err
		}

		(*KeyResult)[k31] = v31
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SetStringExBatchBS(ModuleName string, KeyValue []SSetKeyValueBS, KeyResult *[]SSetKeyResultBS, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(KeyValue)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range KeyValue {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "setStringExBatchBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(3, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*KeyResult) = make([]SSetKeyResultBS, length, length)
		for i32, e32 := int32(0), length; i32 < e32; i32++ {

			err = (*KeyResult)[i32].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}
		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("type not support SIMPLE_LIST.")
		if err != nil {
			return ret, err
		}
	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SetIntExBatchBS(ModuleName string, KeyValue []ISetKeyValueBS, KeyResult *map[int32]int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(KeyValue)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range KeyValue {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "setIntExBatchBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have = _is.SkipTo(codec.MAP, 3, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&length, 0, true)
	if err != nil {
		return ret, err
	}
	(*KeyResult) = make(map[int32]int32)
	for i33, e33 := int32(0), length; i33 < e33; i33++ {
		var k33 int32
		var v33 int32

		err = _is.Read_int32(&k33, 0, false)
		if err != nil {
			return ret, err
		}

		err = _is.Read_int32(&v33, 1, false)
		if err != nil {
			return ret, err
		}

		(*KeyResult)[k33] = v33
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SetLongExBatchBS(ModuleName string, KeyValue []LSetKeyValueBS, KeyResult *map[int64]int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(KeyValue)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range KeyValue {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "setLongExBatchBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have = _is.SkipTo(codec.MAP, 3, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&length, 0, true)
	if err != nil {
		return ret, err
	}
	(*KeyResult) = make(map[int64]int32)
	for i34, e34 := int32(0), length; i34 < e34; i34++ {
		var k34 int64
		var v34 int32

		err = _is.Read_int64(&k34, 0, false)
		if err != nil {
			return ret, err
		}

		err = _is.Read_int32(&v34, 1, false)
		if err != nil {
			return ret, err
		}

		(*KeyResult)[k34] = v34
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) UpdateIntEx(ModuleName string, KeyItem int32, Value string, Dirty bool, ExpireTimeSecond int32, Option Op, RetValue *string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(KeyItem, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Value, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool(Dirty, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(ExpireTimeSecond, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(Option), 6)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "updateIntEx", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_string(&(*RetValue), 7, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) UpdateIntExBS(ModuleName string, KeyItem int32, Value []int8, Dirty bool, ExpireTimeSecond int32, Option Op, RetValue *[]int8, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(KeyItem, 2)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 3)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(Value)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(Value)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool(Dirty, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(ExpireTimeSecond, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(Option), 6)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "updateIntExBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(7, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*RetValue) = make([]int8, length, length)
		for i35, e35 := int32(0), length; i35 < e35; i35++ {

			err = _is.Read_int8(&(*RetValue)[i35], 0, false)
			if err != nil {
				return ret, err
			}
		}
	} else if ty == codec.SIMPLE_LIST {

		err, _ = _is.SkipTo(codec.BYTE, 0, true)
		if err != nil {
			return ret, err
		}
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		err = _is.Read_slice_int8(&(*RetValue), length, true)
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) UpdateLongEx(ModuleName string, KeyItem int64, Value string, Dirty bool, ExpireTimeSecond int32, Option Op, RetValue *string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int64(KeyItem, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Value, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool(Dirty, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(ExpireTimeSecond, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(Option), 6)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "updateLongEx", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_string(&(*RetValue), 7, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) UpdateLongExBS(ModuleName string, KeyItem int64, Value []int8, Dirty bool, ExpireTimeSecond int32, Option Op, RetValue *[]int8, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int64(KeyItem, 2)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 3)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(Value)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(Value)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool(Dirty, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(ExpireTimeSecond, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(Option), 6)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "updateLongExBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(7, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*RetValue) = make([]int8, length, length)
		for i36, e36 := int32(0), length; i36 < e36; i36++ {

			err = _is.Read_int8(&(*RetValue)[i36], 0, false)
			if err != nil {
				return ret, err
			}
		}
	} else if ty == codec.SIMPLE_LIST {

		err, _ = _is.SkipTo(codec.BYTE, 0, true)
		if err != nil {
			return ret, err
		}
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		err = _is.Read_slice_int8(&(*RetValue), length, true)
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) UpdateStringEx(ModuleName string, KeyItem string, Value string, Dirty bool, ExpireTimeSecond int32, Option Op, RetValue *string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(KeyItem, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Value, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool(Dirty, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(ExpireTimeSecond, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(Option), 6)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "updateStringEx", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_string(&(*RetValue), 7, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) UpdateStringExBS(ModuleName string, KeyItem []int8, Value []int8, Dirty bool, ExpireTimeSecond int32, Option Op, RetValue *[]int8, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(KeyItem)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(KeyItem)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 3)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(Value)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(Value)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool(Dirty, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(ExpireTimeSecond, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(Option), 6)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "updateStringExBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(7, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*RetValue) = make([]int8, length, length)
		for i37, e37 := int32(0), length; i37 < e37; i37++ {

			err = _is.Read_int8(&(*RetValue)[i37], 0, false)
			if err != nil {
				return ret, err
			}
		}
	} else if ty == codec.SIMPLE_LIST {

		err, _ = _is.SkipTo(codec.BYTE, 0, true)
		if err != nil {
			return ret, err
		}
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		err = _is.Read_slice_int8(&(*RetValue), length, true)
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) EraseString(ModuleName string, KeyItem string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(KeyItem, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "eraseString", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) EraseInt(ModuleName string, KeyItem int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(KeyItem, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "eraseInt", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) EraseLong(ModuleName string, KeyItem int64, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int64(KeyItem, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "eraseLong", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) EraseStringBatch(ModuleName string, KeyItem map[string]int8, KeyResult *map[string]int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.MAP, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(KeyItem)), 0)
	if err != nil {
		return ret, err
	}
	for k38, v38 := range KeyItem {

		err = _os.Write_string(k38, 0)
		if err != nil {
			return ret, err
		}

		err = _os.Write_int8(v38, 1)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "eraseStringBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have = _is.SkipTo(codec.MAP, 3, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&length, 0, true)
	if err != nil {
		return ret, err
	}
	(*KeyResult) = make(map[string]int32)
	for i39, e39 := int32(0), length; i39 < e39; i39++ {
		var k39 string
		var v39 int32

		err = _is.Read_string(&k39, 0, false)
		if err != nil {
			return ret, err
		}

		err = _is.Read_int32(&v39, 1, false)
		if err != nil {
			return ret, err
		}

		(*KeyResult)[k39] = v39
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) EraseIntBatch(ModuleName string, KeyItem map[int32]int8, KeyResult *map[int32]int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.MAP, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(KeyItem)), 0)
	if err != nil {
		return ret, err
	}
	for k40, v40 := range KeyItem {

		err = _os.Write_int32(k40, 0)
		if err != nil {
			return ret, err
		}

		err = _os.Write_int8(v40, 1)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "eraseIntBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have = _is.SkipTo(codec.MAP, 3, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&length, 0, true)
	if err != nil {
		return ret, err
	}
	(*KeyResult) = make(map[int32]int32)
	for i41, e41 := int32(0), length; i41 < e41; i41++ {
		var k41 int32
		var v41 int32

		err = _is.Read_int32(&k41, 0, false)
		if err != nil {
			return ret, err
		}

		err = _is.Read_int32(&v41, 1, false)
		if err != nil {
			return ret, err
		}

		(*KeyResult)[k41] = v41
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) EraseLongBatch(ModuleName string, KeyItem map[int64]int8, KeyResult *map[int64]int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.MAP, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(KeyItem)), 0)
	if err != nil {
		return ret, err
	}
	for k42, v42 := range KeyItem {

		err = _os.Write_int64(k42, 0)
		if err != nil {
			return ret, err
		}

		err = _os.Write_int8(v42, 1)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "eraseLongBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have = _is.SkipTo(codec.MAP, 3, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&length, 0, true)
	if err != nil {
		return ret, err
	}
	(*KeyResult) = make(map[int64]int32)
	for i43, e43 := int32(0), length; i43 < e43; i43++ {
		var k43 int64
		var v43 int32

		err = _is.Read_int64(&k43, 0, false)
		if err != nil {
			return ret, err
		}

		err = _is.Read_int32(&v43, 1, false)
		if err != nil {
			return ret, err
		}

		(*KeyResult)[k43] = v43
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) EraseStringBatchBS(ModuleName string, KeyItem []SKeyVersionBS, KeyResult *[]SKeyResultBS, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(KeyItem)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range KeyItem {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "eraseStringBatchBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(3, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*KeyResult) = make([]SKeyResultBS, length, length)
		for i44, e44 := int32(0), length; i44 < e44; i44++ {

			err = (*KeyResult)[i44].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}
		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("type not support SIMPLE_LIST.")
		if err != nil {
			return ret, err
		}
	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) EraseStringBS(ModuleName string, KeyItem []int8, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(KeyItem)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(KeyItem)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "eraseStringBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) DelString(ModuleName string, KeyItem string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(KeyItem, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "delString", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) DelInt(ModuleName string, KeyItem int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(KeyItem, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "delInt", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) DelLong(ModuleName string, KeyItem int64, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int64(KeyItem, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "delLong", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) DelStringBatch(ModuleName string, KeyItem map[string]int8, KeyResult *map[string]int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.MAP, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(KeyItem)), 0)
	if err != nil {
		return ret, err
	}
	for k45, v45 := range KeyItem {

		err = _os.Write_string(k45, 0)
		if err != nil {
			return ret, err
		}

		err = _os.Write_int8(v45, 1)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "delStringBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have = _is.SkipTo(codec.MAP, 3, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&length, 0, true)
	if err != nil {
		return ret, err
	}
	(*KeyResult) = make(map[string]int32)
	for i46, e46 := int32(0), length; i46 < e46; i46++ {
		var k46 string
		var v46 int32

		err = _is.Read_string(&k46, 0, false)
		if err != nil {
			return ret, err
		}

		err = _is.Read_int32(&v46, 1, false)
		if err != nil {
			return ret, err
		}

		(*KeyResult)[k46] = v46
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) DelIntBatch(ModuleName string, KeyItem map[int32]int8, KeyResult *map[int32]int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.MAP, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(KeyItem)), 0)
	if err != nil {
		return ret, err
	}
	for k47, v47 := range KeyItem {

		err = _os.Write_int32(k47, 0)
		if err != nil {
			return ret, err
		}

		err = _os.Write_int8(v47, 1)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "delIntBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have = _is.SkipTo(codec.MAP, 3, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&length, 0, true)
	if err != nil {
		return ret, err
	}
	(*KeyResult) = make(map[int32]int32)
	for i48, e48 := int32(0), length; i48 < e48; i48++ {
		var k48 int32
		var v48 int32

		err = _is.Read_int32(&k48, 0, false)
		if err != nil {
			return ret, err
		}

		err = _is.Read_int32(&v48, 1, false)
		if err != nil {
			return ret, err
		}

		(*KeyResult)[k48] = v48
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) DelLongBatch(ModuleName string, KeyItem map[int64]int8, KeyResult *map[int64]int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.MAP, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(KeyItem)), 0)
	if err != nil {
		return ret, err
	}
	for k49, v49 := range KeyItem {

		err = _os.Write_int64(k49, 0)
		if err != nil {
			return ret, err
		}

		err = _os.Write_int8(v49, 1)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "delLongBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have = _is.SkipTo(codec.MAP, 3, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&length, 0, true)
	if err != nil {
		return ret, err
	}
	(*KeyResult) = make(map[int64]int32)
	for i50, e50 := int32(0), length; i50 < e50; i50++ {
		var k50 int64
		var v50 int32

		err = _is.Read_int64(&k50, 0, false)
		if err != nil {
			return ret, err
		}

		err = _is.Read_int32(&v50, 1, false)
		if err != nil {
			return ret, err
		}

		(*KeyResult)[k50] = v50
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) DelStringBatchBS(ModuleName string, KeyItem []SKeyVersionBS, KeyResult *[]SKeyResultBS, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(KeyItem)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range KeyItem {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "delStringBatchBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(3, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*KeyResult) = make([]SKeyResultBS, length, length)
		for i51, e51 := int32(0), length; i51 < e51; i51++ {

			err = (*KeyResult)[i51].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}
		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("type not support SIMPLE_LIST.")
		if err != nil {
			return ret, err
		}
	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) DelStringBS(ModuleName string, KeyItem []int8, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(KeyItem)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(KeyItem)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "delStringBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) GetAllMainKey(ModuleName string, Index int32, Count int32, MainKey *[]string, IsEnd *bool, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(Index, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(Count, 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "getAllMainKey", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(4, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*MainKey) = make([]string, length, length)
		for i52, e52 := int32(0), length; i52 < e52; i52++ {

			err = _is.Read_string(&(*MainKey)[i52], 0, false)
			if err != nil {
				return ret, err
			}
		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("type not support SIMPLE_LIST.")
		if err != nil {
			return ret, err
		}
	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	err = _is.Read_bool(&(*IsEnd), 5, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) Select(ModuleName string, MainIndex string, Field string, VtCond []Condition, VtData *[]map[string]string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(MainIndex, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Field, 3)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtCond)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtCond {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "select", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(5, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*VtData) = make([]map[string]string, length, length)
		for i53, e53 := int32(0), length; i53 < e53; i53++ {

			err, have = _is.SkipTo(codec.MAP, 0, false)
			if err != nil {
				return ret, err
			}
			if have {
				err = _is.Read_int32(&length, 0, true)
				if err != nil {
					return ret, err
				}
				(*VtData)[i53] = make(map[string]string)
				for i54, e54 := int32(0), length; i54 < e54; i54++ {
					var k54 string
					var v54 string

					err = _is.Read_string(&k54, 0, false)
					if err != nil {
						return ret, err
					}

					err = _is.Read_string(&v54, 1, false)
					if err != nil {
						return ret, err
					}

					(*VtData)[i53][k54] = v54
				}
			}
		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("type not support SIMPLE_LIST.")
		if err != nil {
			return ret, err
		}
	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SelectBS(ModuleName string, MainIndex []int8, Field string, VtCond []ConditionBS, VtData *[]map[string][]int8, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MainIndex)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(MainIndex)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Field, 3)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtCond)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtCond {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "selectBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(5, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*VtData) = make([]map[string][]int8, length, length)
		for i55, e55 := int32(0), length; i55 < e55; i55++ {

			err, have = _is.SkipTo(codec.MAP, 0, false)
			if err != nil {
				return ret, err
			}
			if have {
				err = _is.Read_int32(&length, 0, true)
				if err != nil {
					return ret, err
				}
				(*VtData)[i55] = make(map[string][]int8)
				for i56, e56 := int32(0), length; i56 < e56; i56++ {
					var k56 string
					var v56 []int8

					err = _is.Read_string(&k56, 0, false)
					if err != nil {
						return ret, err
					}

					err, have, ty = _is.SkipToNoCheck(1, false)
					if err != nil {
						return ret, err
					}
					if have {
						if ty == codec.LIST {
							err = _is.Read_int32(&length, 0, true)
							if err != nil {
								return ret, err
							}
							v56 = make([]int8, length, length)
							for i57, e57 := int32(0), length; i57 < e57; i57++ {

								err = _is.Read_int8(&v56[i57], 0, false)
								if err != nil {
									return ret, err
								}
							}
						} else if ty == codec.SIMPLE_LIST {

							err, _ = _is.SkipTo(codec.BYTE, 0, true)
							if err != nil {
								return ret, err
							}
							err = _is.Read_int32(&length, 0, true)
							if err != nil {
								return ret, err
							}
							err = _is.Read_slice_int8(&v56, length, true)
							if err != nil {
								return ret, err
							}

						} else {
							err = fmt.Errorf("require vector, but not.")
							if err != nil {
								return ret, err
							}
						}
					}

					(*VtData)[i55][k56] = v56
				}
			}
		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("type not support SIMPLE_LIST.")
		if err != nil {
			return ret, err
		}
	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SelectEx(ModuleName string, MainIndex string, Field string, VtCond []Condition, BGetMKCout bool, VtData *[]map[string]string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(MainIndex, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Field, 3)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtCond)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtCond {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	err = _os.Write_bool(BGetMKCout, 5)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "selectEx", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(6, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*VtData) = make([]map[string]string, length, length)
		for i58, e58 := int32(0), length; i58 < e58; i58++ {

			err, have = _is.SkipTo(codec.MAP, 0, false)
			if err != nil {
				return ret, err
			}
			if have {
				err = _is.Read_int32(&length, 0, true)
				if err != nil {
					return ret, err
				}
				(*VtData)[i58] = make(map[string]string)
				for i59, e59 := int32(0), length; i59 < e59; i59++ {
					var k59 string
					var v59 string

					err = _is.Read_string(&k59, 0, false)
					if err != nil {
						return ret, err
					}

					err = _is.Read_string(&v59, 1, false)
					if err != nil {
						return ret, err
					}

					(*VtData)[i58][k59] = v59
				}
			}
		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("type not support SIMPLE_LIST.")
		if err != nil {
			return ret, err
		}
	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SelectBSEx(ModuleName string, MainIndex []int8, Field string, VtCond []ConditionBS, BGetMKCout bool, VtData *[]map[string][]int8, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MainIndex)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(MainIndex)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Field, 3)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtCond)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtCond {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	err = _os.Write_bool(BGetMKCout, 5)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "selectBSEx", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(6, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*VtData) = make([]map[string][]int8, length, length)
		for i60, e60 := int32(0), length; i60 < e60; i60++ {

			err, have = _is.SkipTo(codec.MAP, 0, false)
			if err != nil {
				return ret, err
			}
			if have {
				err = _is.Read_int32(&length, 0, true)
				if err != nil {
					return ret, err
				}
				(*VtData)[i60] = make(map[string][]int8)
				for i61, e61 := int32(0), length; i61 < e61; i61++ {
					var k61 string
					var v61 []int8

					err = _is.Read_string(&k61, 0, false)
					if err != nil {
						return ret, err
					}

					err, have, ty = _is.SkipToNoCheck(1, false)
					if err != nil {
						return ret, err
					}
					if have {
						if ty == codec.LIST {
							err = _is.Read_int32(&length, 0, true)
							if err != nil {
								return ret, err
							}
							v61 = make([]int8, length, length)
							for i62, e62 := int32(0), length; i62 < e62; i62++ {

								err = _is.Read_int8(&v61[i62], 0, false)
								if err != nil {
									return ret, err
								}
							}
						} else if ty == codec.SIMPLE_LIST {

							err, _ = _is.SkipTo(codec.BYTE, 0, true)
							if err != nil {
								return ret, err
							}
							err = _is.Read_int32(&length, 0, true)
							if err != nil {
								return ret, err
							}
							err = _is.Read_slice_int8(&v61, length, true)
							if err != nil {
								return ret, err
							}

						} else {
							err = fmt.Errorf("require vector, but not.")
							if err != nil {
								return ret, err
							}
						}
					}

					(*VtData)[i60][k61] = v61
				}
			}
		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("type not support SIMPLE_LIST.")
		if err != nil {
			return ret, err
		}
	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SelectBin(ModuleName string, MainKey string, VtCond []Condition, BGetMKCout bool, VtData *[]int8, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(MainKey, 2)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtCond)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtCond {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	err = _os.Write_bool(BGetMKCout, 4)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "selectBin", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(5, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*VtData) = make([]int8, length, length)
		for i63, e63 := int32(0), length; i63 < e63; i63++ {

			err = _is.Read_int8(&(*VtData)[i63], 0, false)
			if err != nil {
				return ret, err
			}
		}
	} else if ty == codec.SIMPLE_LIST {

		err, _ = _is.SkipTo(codec.BYTE, 0, true)
		if err != nil {
			return ret, err
		}
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		err = _is.Read_slice_int8(&(*VtData), length, true)
		if err != nil {
			return ret, err
		}

	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SelectByPos(ModuleName string, MainIndex string, Field string, VtCond []Condition, ICount uint32, DirectionType DirectionType, VtData *[]map[string]string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(MainIndex, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Field, 3)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtCond)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtCond {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	err = _os.Write_uint32(ICount, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(DirectionType), 6)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "selectByPos", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(7, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*VtData) = make([]map[string]string, length, length)
		for i64, e64 := int32(0), length; i64 < e64; i64++ {

			err, have = _is.SkipTo(codec.MAP, 0, false)
			if err != nil {
				return ret, err
			}
			if have {
				err = _is.Read_int32(&length, 0, true)
				if err != nil {
					return ret, err
				}
				(*VtData)[i64] = make(map[string]string)
				for i65, e65 := int32(0), length; i65 < e65; i65++ {
					var k65 string
					var v65 string

					err = _is.Read_string(&k65, 0, false)
					if err != nil {
						return ret, err
					}

					err = _is.Read_string(&v65, 1, false)
					if err != nil {
						return ret, err
					}

					(*VtData)[i64][k65] = v65
				}
			}
		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("type not support SIMPLE_LIST.")
		if err != nil {
			return ret, err
		}
	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SelectBatch(ModuleName string, VtMainKey []string, Field string, VtCond []Condition, VtData *[]MainKeyValue, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtMainKey)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtMainKey {

		err = _os.Write_string(v, 0)
		if err != nil {
			return ret, err
		}
	}

	err = _os.Write_string(Field, 3)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtCond)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtCond {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "selectBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(5, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*VtData) = make([]MainKeyValue, length, length)
		for i66, e66 := int32(0), length; i66 < e66; i66++ {

			err = (*VtData)[i66].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}
		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("type not support SIMPLE_LIST.")
		if err != nil {
			return ret, err
		}
	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SelectBatchBS(ModuleName string, VtMainKey [][]int8, Field string, VtCond []ConditionBS, VtData *[]MainKeyValueBS, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtMainKey)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtMainKey {

		err = _os.WriteHead(codec.SIMPLE_LIST, 0)
		if err != nil {
			return ret, err
		}
		err = _os.WriteHead(codec.BYTE, 0)
		if err != nil {
			return ret, err
		}
		err = _os.Write_int32(int32(len(v)), 0)
		if err != nil {
			return ret, err
		}
		err = _os.Write_slice_int8(v)
		if err != nil {
			return ret, err
		}
	}

	err = _os.Write_string(Field, 3)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtCond)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtCond {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "selectBatchBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(5, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*VtData) = make([]MainKeyValueBS, length, length)
		for i67, e67 := int32(0), length; i67 < e67; i67++ {

			err = (*VtData)[i67].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}
		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("type not support SIMPLE_LIST.")
		if err != nil {
			return ret, err
		}
	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SelectBinBatch(ModuleName string, VtMainKey []string, VtCond []Condition, VtData *[]MainKeyValueBin, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtMainKey)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtMainKey {

		err = _os.Write_string(v, 0)
		if err != nil {
			return ret, err
		}
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtCond)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtCond {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "selectBinBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(4, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*VtData) = make([]MainKeyValueBin, length, length)
		for i68, e68 := int32(0), length; i68 < e68; i68++ {

			err = (*VtData)[i68].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}
		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("type not support SIMPLE_LIST.")
		if err != nil {
			return ret, err
		}
	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SelectBatchEx(ModuleName string, VtMUKey []Record, Field string, VtData *[]Record, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtMUKey)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtMUKey {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	err = _os.Write_string(Field, 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "selectBatchEx", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(4, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*VtData) = make([]Record, length, length)
		for i69, e69 := int32(0), length; i69 < e69; i69++ {

			err = (*VtData)[i69].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}
		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("type not support SIMPLE_LIST.")
		if err != nil {
			return ret, err
		}
	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SelectBatchExBS(ModuleName string, VtMUKey []RecordBS, Field string, VtData *[]RecordBS, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtMUKey)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtMUKey {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	err = _os.Write_string(Field, 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "selectBatchExBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(4, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*VtData) = make([]RecordBS, length, length)
		for i70, e70 := int32(0), length; i70 < e70; i70++ {

			err = (*VtData)[i70].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}
		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("type not support SIMPLE_LIST.")
		if err != nil {
			return ret, err
		}
	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SelectBatchOr(ModuleName string, VtKey []MainKeyCondition, VtData *[]MainKeyValue, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtKey)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtKey {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "selectBatchOr", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(3, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*VtData) = make([]MainKeyValue, length, length)
		for i71, e71 := int32(0), length; i71 < e71; i71++ {

			err = (*VtData)[i71].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}
		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("type not support SIMPLE_LIST.")
		if err != nil {
			return ret, err
		}
	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SelectBatchOrBS(ModuleName string, VtKey []MainKeyConditionBS, VtData *[]MainKeyValueBS, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtKey)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtKey {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "selectBatchOrBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(3, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*VtData) = make([]MainKeyValueBS, length, length)
		for i72, e72 := int32(0), length; i72 < e72; i72++ {

			err = (*VtData)[i72].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}
		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("type not support SIMPLE_LIST.")
		if err != nil {
			return ret, err
		}
	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) Insert(ModuleName string, MainIndex string, MpValue map[string]UpdateValue, Replace bool, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(MainIndex, 2)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.MAP, 3)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MpValue)), 0)
	if err != nil {
		return ret, err
	}
	for k73, v73 := range MpValue {

		err = _os.Write_string(k73, 0)
		if err != nil {
			return ret, err
		}

		err = v73.WriteBlock(_os, 1)
		if err != nil {
			return ret, err
		}
	}

	err = _os.Write_bool(Replace, 4)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "insert", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) InsertBS(ModuleName string, MainIndex []int8, MpValue map[string]UpdateValueBS, Replace bool, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MainIndex)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(MainIndex)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.MAP, 3)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MpValue)), 0)
	if err != nil {
		return ret, err
	}
	for k74, v74 := range MpValue {

		err = _os.Write_string(k74, 0)
		if err != nil {
			return ret, err
		}

		err = v74.WriteBlock(_os, 1)
		if err != nil {
			return ret, err
		}
	}

	err = _os.Write_bool(Replace, 4)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "insertBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) InsertEx(ModuleName string, MainIndex string, MpValue map[string]UpdateValue, Ver int8, Dirty bool, Replace bool, ExpireTimeSecond int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(MainIndex, 2)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.MAP, 3)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MpValue)), 0)
	if err != nil {
		return ret, err
	}
	for k75, v75 := range MpValue {

		err = _os.Write_string(k75, 0)
		if err != nil {
			return ret, err
		}

		err = v75.WriteBlock(_os, 1)
		if err != nil {
			return ret, err
		}
	}

	err = _os.Write_int8(Ver, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool(Dirty, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool(Replace, 6)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(ExpireTimeSecond, 7)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "insertEx", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) InsertBSEx(ModuleName string, MainIndex []int8, MpValue map[string]UpdateValueBS, Ver int8, Dirty bool, Replace bool, ExpireTimeSecond int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MainIndex)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(MainIndex)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.MAP, 3)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MpValue)), 0)
	if err != nil {
		return ret, err
	}
	for k76, v76 := range MpValue {

		err = _os.Write_string(k76, 0)
		if err != nil {
			return ret, err
		}

		err = v76.WriteBlock(_os, 1)
		if err != nil {
			return ret, err
		}
	}

	err = _os.Write_int8(Ver, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool(Dirty, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool(Replace, 6)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(ExpireTimeSecond, 7)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "insertBSEx", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) InsertBatch(ModuleName string, VtKeyValue []InsertKeyValue, MpFailIndexReason *map[int32]int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtKeyValue)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtKeyValue {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "insertBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have = _is.SkipTo(codec.MAP, 3, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&length, 0, true)
	if err != nil {
		return ret, err
	}
	(*MpFailIndexReason) = make(map[int32]int32)
	for i77, e77 := int32(0), length; i77 < e77; i77++ {
		var k77 int32
		var v77 int32

		err = _is.Read_int32(&k77, 0, false)
		if err != nil {
			return ret, err
		}

		err = _is.Read_int32(&v77, 1, false)
		if err != nil {
			return ret, err
		}

		(*MpFailIndexReason)[k77] = v77
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) InsertBatchBS(ModuleName string, VtKeyValue []InsertKeyValueBS, MpFailIndexReason *map[int32]int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtKeyValue)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtKeyValue {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "insertBatchBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have = _is.SkipTo(codec.MAP, 3, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&length, 0, true)
	if err != nil {
		return ret, err
	}
	(*MpFailIndexReason) = make(map[int32]int32)
	for i78, e78 := int32(0), length; i78 < e78; i78++ {
		var k78 int32
		var v78 int32

		err = _is.Read_int32(&k78, 0, false)
		if err != nil {
			return ret, err
		}

		err = _is.Read_int32(&v78, 1, false)
		if err != nil {
			return ret, err
		}

		(*MpFailIndexReason)[k78] = v78
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) Update(ModuleName string, MainIndex string, MpValue map[string]UpdateValue, VtCond []Condition, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(MainIndex, 2)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.MAP, 3)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MpValue)), 0)
	if err != nil {
		return ret, err
	}
	for k79, v79 := range MpValue {

		err = _os.Write_string(k79, 0)
		if err != nil {
			return ret, err
		}

		err = v79.WriteBlock(_os, 1)
		if err != nil {
			return ret, err
		}
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtCond)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtCond {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "update", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) UpdateBS(ModuleName string, MainIndex []int8, MpValue map[string]UpdateValueBS, VtCond []ConditionBS, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MainIndex)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(MainIndex)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.MAP, 3)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MpValue)), 0)
	if err != nil {
		return ret, err
	}
	for k80, v80 := range MpValue {

		err = _os.Write_string(k80, 0)
		if err != nil {
			return ret, err
		}

		err = v80.WriteBlock(_os, 1)
		if err != nil {
			return ret, err
		}
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtCond)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtCond {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "updateBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) UpdateEx(ModuleName string, MainIndex string, MpValue map[string]UpdateValue, VtCond []Condition, Ver int8, Dirty bool, ExpireTimeSecond int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(MainIndex, 2)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.MAP, 3)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MpValue)), 0)
	if err != nil {
		return ret, err
	}
	for k81, v81 := range MpValue {

		err = _os.Write_string(k81, 0)
		if err != nil {
			return ret, err
		}

		err = v81.WriteBlock(_os, 1)
		if err != nil {
			return ret, err
		}
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtCond)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtCond {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	err = _os.Write_int8(Ver, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool(Dirty, 6)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(ExpireTimeSecond, 7)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "updateEx", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) UpdateBSEx(ModuleName string, MainIndex []int8, MpValue map[string]UpdateValueBS, VtCond []ConditionBS, Ver int8, Dirty bool, ExpireTimeSecond int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MainIndex)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(MainIndex)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.MAP, 3)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MpValue)), 0)
	if err != nil {
		return ret, err
	}
	for k82, v82 := range MpValue {

		err = _os.Write_string(k82, 0)
		if err != nil {
			return ret, err
		}

		err = v82.WriteBlock(_os, 1)
		if err != nil {
			return ret, err
		}
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtCond)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtCond {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	err = _os.Write_int8(Ver, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool(Dirty, 6)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(ExpireTimeSecond, 7)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "updateBSEx", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) UpdateAtom(ModuleName string, MainIndex string, MpValue map[string]UpdateValue, VtCond []Condition, Dirty bool, ExpireTimeSecond int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(MainIndex, 2)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.MAP, 3)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MpValue)), 0)
	if err != nil {
		return ret, err
	}
	for k83, v83 := range MpValue {

		err = _os.Write_string(k83, 0)
		if err != nil {
			return ret, err
		}

		err = v83.WriteBlock(_os, 1)
		if err != nil {
			return ret, err
		}
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtCond)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtCond {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	err = _os.Write_bool(Dirty, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(ExpireTimeSecond, 6)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "updateAtom", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) UpdateBSAtom(ModuleName string, MainIndex []int8, MpValue map[string]UpdateValueBS, VtCond []ConditionBS, Dirty bool, ExpireTimeSecond int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MainIndex)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(MainIndex)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.MAP, 3)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MpValue)), 0)
	if err != nil {
		return ret, err
	}
	for k84, v84 := range MpValue {

		err = _os.Write_string(k84, 0)
		if err != nil {
			return ret, err
		}

		err = v84.WriteBlock(_os, 1)
		if err != nil {
			return ret, err
		}
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtCond)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtCond {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	err = _os.Write_bool(Dirty, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(ExpireTimeSecond, 6)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "updateBSAtom", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) UpdateBatch(ModuleName string, VtKeyValue []UpdateKeyValue, MpFailIndexReason *map[int32]int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtKeyValue)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtKeyValue {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "updateBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have = _is.SkipTo(codec.MAP, 3, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&length, 0, true)
	if err != nil {
		return ret, err
	}
	(*MpFailIndexReason) = make(map[int32]int32)
	for i85, e85 := int32(0), length; i85 < e85; i85++ {
		var k85 int32
		var v85 int32

		err = _is.Read_int32(&k85, 0, false)
		if err != nil {
			return ret, err
		}

		err = _is.Read_int32(&v85, 1, false)
		if err != nil {
			return ret, err
		}

		(*MpFailIndexReason)[k85] = v85
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) UpdateBatchBS(ModuleName string, VtKeyValue []UpdateKeyValueBS, MpFailIndexReason *map[int32]int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtKeyValue)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtKeyValue {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "updateBatchBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have = _is.SkipTo(codec.MAP, 3, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&length, 0, true)
	if err != nil {
		return ret, err
	}
	(*MpFailIndexReason) = make(map[int32]int32)
	for i86, e86 := int32(0), length; i86 < e86; i86++ {
		var k86 int32
		var v86 int32

		err = _is.Read_int32(&k86, 0, false)
		if err != nil {
			return ret, err
		}

		err = _is.Read_int32(&v86, 1, false)
		if err != nil {
			return ret, err
		}

		(*MpFailIndexReason)[k86] = v86
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) Erase(ModuleName string, MainIndex string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(MainIndex, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "erase", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) EraseBS(ModuleName string, MainIndex []int8, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MainIndex)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(MainIndex)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "eraseBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) Del(ModuleName string, MainIndex string, VtCond []Condition, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(MainIndex, 2)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtCond)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtCond {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "del", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) DelBatch(ModuleName string, VtCond []DelCondition, MRet *map[int32]int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtCond)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtCond {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "delBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have = _is.SkipTo(codec.MAP, 3, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&length, 0, true)
	if err != nil {
		return ret, err
	}
	(*MRet) = make(map[int32]int32)
	for i87, e87 := int32(0), length; i87 < e87; i87++ {
		var k87 int32
		var v87 int32

		err = _is.Read_int32(&k87, 0, false)
		if err != nil {
			return ret, err
		}

		err = _is.Read_int32(&v87, 1, false)
		if err != nil {
			return ret, err
		}

		(*MRet)[k87] = v87
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) DelBS(ModuleName string, MainIndex []int8, VtCond []ConditionBS, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MainIndex)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(MainIndex)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtCond)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtCond {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "delBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) GetMainKeyCount(ModuleName string, MainKey string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(MainKey, 2)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "getMainKeyCount", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) GetMKAllMainKey(ModuleName string, Index int32, Count int32, MainKey *[]string, IsEnd *bool, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(Index, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(Count, 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "getMKAllMainKey", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(4, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*MainKey) = make([]string, length, length)
		for i88, e88 := int32(0), length; i88 < e88; i88++ {

			err = _is.Read_string(&(*MainKey)[i88], 0, false)
			if err != nil {
				return ret, err
			}
		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("type not support SIMPLE_LIST.")
		if err != nil {
			return ret, err
		}
	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	err = _is.Read_bool(&(*IsEnd), 5, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) GetRangeList(ModuleName string, MainKey string, Field string, IStart int64, IEnd int64, VtData *[]map[string]string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(MainKey, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Field, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int64(IStart, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int64(IEnd, 5)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "getRangeList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(6, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*VtData) = make([]map[string]string, length, length)
		for i89, e89 := int32(0), length; i89 < e89; i89++ {

			err, have = _is.SkipTo(codec.MAP, 0, false)
			if err != nil {
				return ret, err
			}
			if have {
				err = _is.Read_int32(&length, 0, true)
				if err != nil {
					return ret, err
				}
				(*VtData)[i89] = make(map[string]string)
				for i90, e90 := int32(0), length; i90 < e90; i90++ {
					var k90 string
					var v90 string

					err = _is.Read_string(&k90, 0, false)
					if err != nil {
						return ret, err
					}

					err = _is.Read_string(&v90, 1, false)
					if err != nil {
						return ret, err
					}

					(*VtData)[i89][k90] = v90
				}
			}
		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("type not support SIMPLE_LIST.")
		if err != nil {
			return ret, err
		}
	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) GetRangeListBS(ModuleName string, MainKey []int8, Field string, IStart int64, IEnd int64, VtData *[]map[string][]int8, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MainKey)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(MainKey)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Field, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int64(IStart, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int64(IEnd, 5)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "getRangeListBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(6, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*VtData) = make([]map[string][]int8, length, length)
		for i91, e91 := int32(0), length; i91 < e91; i91++ {

			err, have = _is.SkipTo(codec.MAP, 0, false)
			if err != nil {
				return ret, err
			}
			if have {
				err = _is.Read_int32(&length, 0, true)
				if err != nil {
					return ret, err
				}
				(*VtData)[i91] = make(map[string][]int8)
				for i92, e92 := int32(0), length; i92 < e92; i92++ {
					var k92 string
					var v92 []int8

					err = _is.Read_string(&k92, 0, false)
					if err != nil {
						return ret, err
					}

					err, have, ty = _is.SkipToNoCheck(1, false)
					if err != nil {
						return ret, err
					}
					if have {
						if ty == codec.LIST {
							err = _is.Read_int32(&length, 0, true)
							if err != nil {
								return ret, err
							}
							v92 = make([]int8, length, length)
							for i93, e93 := int32(0), length; i93 < e93; i93++ {

								err = _is.Read_int8(&v92[i93], 0, false)
								if err != nil {
									return ret, err
								}
							}
						} else if ty == codec.SIMPLE_LIST {

							err, _ = _is.SkipTo(codec.BYTE, 0, true)
							if err != nil {
								return ret, err
							}
							err = _is.Read_int32(&length, 0, true)
							if err != nil {
								return ret, err
							}
							err = _is.Read_slice_int8(&v92, length, true)
							if err != nil {
								return ret, err
							}

						} else {
							err = fmt.Errorf("require vector, but not.")
							if err != nil {
								return ret, err
							}
						}
					}

					(*VtData)[i91][k92] = v92
				}
			}
		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("type not support SIMPLE_LIST.")
		if err != nil {
			return ret, err
		}
	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) GetList(ModuleName string, MainKey string, Field string, IPos int64, MData *map[string]string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(MainKey, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Field, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int64(IPos, 4)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "getList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have = _is.SkipTo(codec.MAP, 5, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&length, 0, true)
	if err != nil {
		return ret, err
	}
	(*MData) = make(map[string]string)
	for i94, e94 := int32(0), length; i94 < e94; i94++ {
		var k94 string
		var v94 string

		err = _is.Read_string(&k94, 0, false)
		if err != nil {
			return ret, err
		}

		err = _is.Read_string(&v94, 1, false)
		if err != nil {
			return ret, err
		}

		(*MData)[k94] = v94
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) GetListBS(ModuleName string, MainKey []int8, Field string, IPos int64, MData *map[string][]int8, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MainKey)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(MainKey)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Field, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int64(IPos, 4)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "getListBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have = _is.SkipTo(codec.MAP, 5, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&length, 0, true)
	if err != nil {
		return ret, err
	}
	(*MData) = make(map[string][]int8)
	for i95, e95 := int32(0), length; i95 < e95; i95++ {
		var k95 string
		var v95 []int8

		err = _is.Read_string(&k95, 0, false)
		if err != nil {
			return ret, err
		}

		err, have, ty = _is.SkipToNoCheck(1, false)
		if err != nil {
			return ret, err
		}
		if have {
			if ty == codec.LIST {
				err = _is.Read_int32(&length, 0, true)
				if err != nil {
					return ret, err
				}
				v95 = make([]int8, length, length)
				for i96, e96 := int32(0), length; i96 < e96; i96++ {

					err = _is.Read_int8(&v95[i96], 0, false)
					if err != nil {
						return ret, err
					}
				}
			} else if ty == codec.SIMPLE_LIST {

				err, _ = _is.SkipTo(codec.BYTE, 0, true)
				if err != nil {
					return ret, err
				}
				err = _is.Read_int32(&length, 0, true)
				if err != nil {
					return ret, err
				}
				err = _is.Read_slice_int8(&v95, length, true)
				if err != nil {
					return ret, err
				}

			} else {
				err = fmt.Errorf("require vector, but not.")
				if err != nil {
					return ret, err
				}
			}
		}

		(*MData)[k95] = v95
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) GetSet(ModuleName string, MainKey string, Field string, VtData *[]map[string]string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(MainKey, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Field, 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "getSet", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(4, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*VtData) = make([]map[string]string, length, length)
		for i97, e97 := int32(0), length; i97 < e97; i97++ {

			err, have = _is.SkipTo(codec.MAP, 0, false)
			if err != nil {
				return ret, err
			}
			if have {
				err = _is.Read_int32(&length, 0, true)
				if err != nil {
					return ret, err
				}
				(*VtData)[i97] = make(map[string]string)
				for i98, e98 := int32(0), length; i98 < e98; i98++ {
					var k98 string
					var v98 string

					err = _is.Read_string(&k98, 0, false)
					if err != nil {
						return ret, err
					}

					err = _is.Read_string(&v98, 1, false)
					if err != nil {
						return ret, err
					}

					(*VtData)[i97][k98] = v98
				}
			}
		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("type not support SIMPLE_LIST.")
		if err != nil {
			return ret, err
		}
	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) GetSetBS(ModuleName string, MainKey []int8, Field string, VtData *[]map[string][]int8, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MainKey)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(MainKey)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Field, 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "getSetBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(4, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*VtData) = make([]map[string][]int8, length, length)
		for i99, e99 := int32(0), length; i99 < e99; i99++ {

			err, have = _is.SkipTo(codec.MAP, 0, false)
			if err != nil {
				return ret, err
			}
			if have {
				err = _is.Read_int32(&length, 0, true)
				if err != nil {
					return ret, err
				}
				(*VtData)[i99] = make(map[string][]int8)
				for i100, e100 := int32(0), length; i100 < e100; i100++ {
					var k100 string
					var v100 []int8

					err = _is.Read_string(&k100, 0, false)
					if err != nil {
						return ret, err
					}

					err, have, ty = _is.SkipToNoCheck(1, false)
					if err != nil {
						return ret, err
					}
					if have {
						if ty == codec.LIST {
							err = _is.Read_int32(&length, 0, true)
							if err != nil {
								return ret, err
							}
							v100 = make([]int8, length, length)
							for i101, e101 := int32(0), length; i101 < e101; i101++ {

								err = _is.Read_int8(&v100[i101], 0, false)
								if err != nil {
									return ret, err
								}
							}
						} else if ty == codec.SIMPLE_LIST {

							err, _ = _is.SkipTo(codec.BYTE, 0, true)
							if err != nil {
								return ret, err
							}
							err = _is.Read_int32(&length, 0, true)
							if err != nil {
								return ret, err
							}
							err = _is.Read_slice_int8(&v100, length, true)
							if err != nil {
								return ret, err
							}

						} else {
							err = fmt.Errorf("require vector, but not.")
							if err != nil {
								return ret, err
							}
						}
					}

					(*VtData)[i99][k100] = v100
				}
			}
		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("type not support SIMPLE_LIST.")
		if err != nil {
			return ret, err
		}
	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) GetScoreZSet(ModuleName string, MainKey string, VtCond []Condition, IScore *float64, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(MainKey, 2)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtCond)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtCond {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "getScoreZSet", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_float64(&(*IScore), 4, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) GetRankZSet(ModuleName string, MainKey string, VtCond []Condition, BOrder bool, IPos *int64, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(MainKey, 2)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtCond)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtCond {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	err = _os.Write_bool(BOrder, 4)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "getRankZSet", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int64(&(*IPos), 5, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) GetRangeZSet(ModuleName string, MainKey string, Field string, IStart int64, IEnd int64, BUp bool, VtData *[]map[string]string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(MainKey, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Field, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int64(IStart, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int64(IEnd, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool(BUp, 6)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "getRangeZSet", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(7, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*VtData) = make([]map[string]string, length, length)
		for i102, e102 := int32(0), length; i102 < e102; i102++ {

			err, have = _is.SkipTo(codec.MAP, 0, false)
			if err != nil {
				return ret, err
			}
			if have {
				err = _is.Read_int32(&length, 0, true)
				if err != nil {
					return ret, err
				}
				(*VtData)[i102] = make(map[string]string)
				for i103, e103 := int32(0), length; i103 < e103; i103++ {
					var k103 string
					var v103 string

					err = _is.Read_string(&k103, 0, false)
					if err != nil {
						return ret, err
					}

					err = _is.Read_string(&v103, 1, false)
					if err != nil {
						return ret, err
					}

					(*VtData)[i102][k103] = v103
				}
			}
		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("type not support SIMPLE_LIST.")
		if err != nil {
			return ret, err
		}
	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SelectZSetBatch(ModuleName string, VtMainKey []string, Field string, VtCond []Condition, VtData *[]MainKeyValue, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtMainKey)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtMainKey {

		err = _os.Write_string(v, 0)
		if err != nil {
			return ret, err
		}
	}

	err = _os.Write_string(Field, 3)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtCond)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtCond {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "selectZSetBatch", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(5, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*VtData) = make([]MainKeyValue, length, length)
		for i104, e104 := int32(0), length; i104 < e104; i104++ {

			err = (*VtData)[i104].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}
		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("type not support SIMPLE_LIST.")
		if err != nil {
			return ret, err
		}
	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) GetRangeZSetByScore(ModuleName string, MainKey string, Field string, IMin float64, IMax float64, VtData *[]map[string]string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(MainKey, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Field, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_float64(IMin, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_float64(IMax, 5)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "getRangeZSetByScore", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(6, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*VtData) = make([]map[string]string, length, length)
		for i105, e105 := int32(0), length; i105 < e105; i105++ {

			err, have = _is.SkipTo(codec.MAP, 0, false)
			if err != nil {
				return ret, err
			}
			if have {
				err = _is.Read_int32(&length, 0, true)
				if err != nil {
					return ret, err
				}
				(*VtData)[i105] = make(map[string]string)
				for i106, e106 := int32(0), length; i106 < e106; i106++ {
					var k106 string
					var v106 string

					err = _is.Read_string(&k106, 0, false)
					if err != nil {
						return ret, err
					}

					err = _is.Read_string(&v106, 1, false)
					if err != nil {
						return ret, err
					}

					(*VtData)[i105][k106] = v106
				}
			}
		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("type not support SIMPLE_LIST.")
		if err != nil {
			return ret, err
		}
	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SelectZSetBatchBS(ModuleName string, VtMainKey [][]int8, Field string, VtCond []ConditionBS, VtData *[]MainKeyValueBS, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtMainKey)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtMainKey {

		err = _os.WriteHead(codec.SIMPLE_LIST, 0)
		if err != nil {
			return ret, err
		}
		err = _os.WriteHead(codec.BYTE, 0)
		if err != nil {
			return ret, err
		}
		err = _os.Write_int32(int32(len(v)), 0)
		if err != nil {
			return ret, err
		}
		err = _os.Write_slice_int8(v)
		if err != nil {
			return ret, err
		}
	}

	err = _os.Write_string(Field, 3)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 4)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtCond)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtCond {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "selectZSetBatchBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(5, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*VtData) = make([]MainKeyValueBS, length, length)
		for i107, e107 := int32(0), length; i107 < e107; i107++ {

			err = (*VtData)[i107].ReadBlock(_is, 0, false)
			if err != nil {
				return ret, err
			}
		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("type not support SIMPLE_LIST.")
		if err != nil {
			return ret, err
		}
	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) GetScoreZSetBS(ModuleName string, MainKey []int8, VtCond []ConditionBS, IScore *float64, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MainKey)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(MainKey)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtCond)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtCond {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "getScoreZSetBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_float64(&(*IScore), 4, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) GetRankZSetBS(ModuleName string, MainKey []int8, VtCond []ConditionBS, BOrder bool, IPos *int64, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MainKey)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(MainKey)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtCond)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtCond {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	err = _os.Write_bool(BOrder, 4)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "getRankZSetBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int64(&(*IPos), 5, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) GetRangeZSetBS(ModuleName string, MainKey []int8, Field string, IStart int64, IEnd int64, BUp bool, VtData *[]map[string][]int8, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MainKey)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(MainKey)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Field, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int64(IStart, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int64(IEnd, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool(BUp, 6)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "getRangeZSetBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(7, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*VtData) = make([]map[string][]int8, length, length)
		for i108, e108 := int32(0), length; i108 < e108; i108++ {

			err, have = _is.SkipTo(codec.MAP, 0, false)
			if err != nil {
				return ret, err
			}
			if have {
				err = _is.Read_int32(&length, 0, true)
				if err != nil {
					return ret, err
				}
				(*VtData)[i108] = make(map[string][]int8)
				for i109, e109 := int32(0), length; i109 < e109; i109++ {
					var k109 string
					var v109 []int8

					err = _is.Read_string(&k109, 0, false)
					if err != nil {
						return ret, err
					}

					err, have, ty = _is.SkipToNoCheck(1, false)
					if err != nil {
						return ret, err
					}
					if have {
						if ty == codec.LIST {
							err = _is.Read_int32(&length, 0, true)
							if err != nil {
								return ret, err
							}
							v109 = make([]int8, length, length)
							for i110, e110 := int32(0), length; i110 < e110; i110++ {

								err = _is.Read_int8(&v109[i110], 0, false)
								if err != nil {
									return ret, err
								}
							}
						} else if ty == codec.SIMPLE_LIST {

							err, _ = _is.SkipTo(codec.BYTE, 0, true)
							if err != nil {
								return ret, err
							}
							err = _is.Read_int32(&length, 0, true)
							if err != nil {
								return ret, err
							}
							err = _is.Read_slice_int8(&v109, length, true)
							if err != nil {
								return ret, err
							}

						} else {
							err = fmt.Errorf("require vector, but not.")
							if err != nil {
								return ret, err
							}
						}
					}

					(*VtData)[i108][k109] = v109
				}
			}
		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("type not support SIMPLE_LIST.")
		if err != nil {
			return ret, err
		}
	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) GetRangeZSetByScoreBS(ModuleName string, MainKey []int8, Field string, IMin float64, IMax float64, VtData *[]map[string][]int8, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MainKey)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(MainKey)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Field, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_float64(IMin, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_float64(IMax, 5)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "getRangeZSetByScoreBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have, ty = _is.SkipToNoCheck(6, true)
	if err != nil {
		return ret, err
	}

	if ty == codec.LIST {
		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return ret, err
		}
		(*VtData) = make([]map[string][]int8, length, length)
		for i111, e111 := int32(0), length; i111 < e111; i111++ {

			err, have = _is.SkipTo(codec.MAP, 0, false)
			if err != nil {
				return ret, err
			}
			if have {
				err = _is.Read_int32(&length, 0, true)
				if err != nil {
					return ret, err
				}
				(*VtData)[i111] = make(map[string][]int8)
				for i112, e112 := int32(0), length; i112 < e112; i112++ {
					var k112 string
					var v112 []int8

					err = _is.Read_string(&k112, 0, false)
					if err != nil {
						return ret, err
					}

					err, have, ty = _is.SkipToNoCheck(1, false)
					if err != nil {
						return ret, err
					}
					if have {
						if ty == codec.LIST {
							err = _is.Read_int32(&length, 0, true)
							if err != nil {
								return ret, err
							}
							v112 = make([]int8, length, length)
							for i113, e113 := int32(0), length; i113 < e113; i113++ {

								err = _is.Read_int8(&v112[i113], 0, false)
								if err != nil {
									return ret, err
								}
							}
						} else if ty == codec.SIMPLE_LIST {

							err, _ = _is.SkipTo(codec.BYTE, 0, true)
							if err != nil {
								return ret, err
							}
							err = _is.Read_int32(&length, 0, true)
							if err != nil {
								return ret, err
							}
							err = _is.Read_slice_int8(&v112, length, true)
							if err != nil {
								return ret, err
							}

						} else {
							err = fmt.Errorf("require vector, but not.")
							if err != nil {
								return ret, err
							}
						}
					}

					(*VtData)[i111][k112] = v112
				}
			}
		}
	} else if ty == codec.SIMPLE_LIST {
		err = fmt.Errorf("type not support SIMPLE_LIST.")
		if err != nil {
			return ret, err
		}
	} else {
		err = fmt.Errorf("require vector, but not.")
		if err != nil {
			return ret, err
		}
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) PushList(ModuleName string, MainKey string, MpValue []InsertKeyValue, BHead bool, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(MainKey, 2)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MpValue)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range MpValue {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	err = _os.Write_bool(BHead, 4)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "pushList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) PopList(ModuleName string, MainKey string, BHead bool, Value *map[string]string, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(MainKey, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool(BHead, 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "popList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have = _is.SkipTo(codec.MAP, 4, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&length, 0, true)
	if err != nil {
		return ret, err
	}
	(*Value) = make(map[string]string)
	for i114, e114 := int32(0), length; i114 < e114; i114++ {
		var k114 string
		var v114 string

		err = _is.Read_string(&k114, 0, false)
		if err != nil {
			return ret, err
		}

		err = _is.Read_string(&v114, 1, false)
		if err != nil {
			return ret, err
		}

		(*Value)[k114] = v114
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) ReplaceList(ModuleName string, MainKey string, MpValue map[string]UpdateValue, IPos int64, IExpireTime int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(MainKey, 2)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.MAP, 3)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MpValue)), 0)
	if err != nil {
		return ret, err
	}
	for k115, v115 := range MpValue {

		err = _os.Write_string(k115, 0)
		if err != nil {
			return ret, err
		}

		err = v115.WriteBlock(_os, 1)
		if err != nil {
			return ret, err
		}
	}

	err = _os.Write_int64(IPos, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(IExpireTime, 5)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "replaceList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) TrimList(ModuleName string, MainKey string, IStart int64, IEnd int64, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(MainKey, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int64(IStart, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int64(IEnd, 4)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "trimList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) RemList(ModuleName string, MainKey string, BHead bool, ICount int64, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(MainKey, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool(BHead, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int64(ICount, 4)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "remList", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) PushListBS(ModuleName string, MainKey []int8, MpValue []InsertKeyValueBS, BHead bool, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MainKey)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(MainKey)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MpValue)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range MpValue {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	err = _os.Write_bool(BHead, 4)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "pushListBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) PopListBS(ModuleName string, MainKey []int8, BHead bool, Value *map[string][]int8, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MainKey)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(MainKey)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool(BHead, 3)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "popListBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	err, have = _is.SkipTo(codec.MAP, 4, true)
	if err != nil {
		return ret, err
	}

	err = _is.Read_int32(&length, 0, true)
	if err != nil {
		return ret, err
	}
	(*Value) = make(map[string][]int8)
	for i116, e116 := int32(0), length; i116 < e116; i116++ {
		var k116 string
		var v116 []int8

		err = _is.Read_string(&k116, 0, false)
		if err != nil {
			return ret, err
		}

		err, have, ty = _is.SkipToNoCheck(1, false)
		if err != nil {
			return ret, err
		}
		if have {
			if ty == codec.LIST {
				err = _is.Read_int32(&length, 0, true)
				if err != nil {
					return ret, err
				}
				v116 = make([]int8, length, length)
				for i117, e117 := int32(0), length; i117 < e117; i117++ {

					err = _is.Read_int8(&v116[i117], 0, false)
					if err != nil {
						return ret, err
					}
				}
			} else if ty == codec.SIMPLE_LIST {

				err, _ = _is.SkipTo(codec.BYTE, 0, true)
				if err != nil {
					return ret, err
				}
				err = _is.Read_int32(&length, 0, true)
				if err != nil {
					return ret, err
				}
				err = _is.Read_slice_int8(&v116, length, true)
				if err != nil {
					return ret, err
				}

			} else {
				err = fmt.Errorf("require vector, but not.")
				if err != nil {
					return ret, err
				}
			}
		}

		(*Value)[k116] = v116
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) ReplaceListBS(ModuleName string, MainKey []int8, MpValue map[string]UpdateValueBS, IPos int64, IExpireTime int32, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MainKey)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(MainKey)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.MAP, 3)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MpValue)), 0)
	if err != nil {
		return ret, err
	}
	for k118, v118 := range MpValue {

		err = _os.Write_string(k118, 0)
		if err != nil {
			return ret, err
		}

		err = v118.WriteBlock(_os, 1)
		if err != nil {
			return ret, err
		}
	}

	err = _os.Write_int64(IPos, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(IExpireTime, 5)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "replaceListBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) TrimListBS(ModuleName string, MainKey []int8, IStart int64, IEnd int64, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MainKey)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(MainKey)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int64(IStart, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int64(IEnd, 4)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "trimListBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) RemListBS(ModuleName string, MainKey []int8, BHead bool, ICount int64, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MainKey)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(MainKey)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool(BHead, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int64(ICount, 4)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "remListBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) AddSet(ModuleName string, MainKey string, MpValue map[string]UpdateValue, IExpireTime int32, IVersion int8, BDirty bool, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(MainKey, 2)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.MAP, 3)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MpValue)), 0)
	if err != nil {
		return ret, err
	}
	for k119, v119 := range MpValue {

		err = _os.Write_string(k119, 0)
		if err != nil {
			return ret, err
		}

		err = v119.WriteBlock(_os, 1)
		if err != nil {
			return ret, err
		}
	}

	err = _os.Write_int32(IExpireTime, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int8(IVersion, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool(BDirty, 6)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "addSet", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) DelSet(ModuleName string, MainKey string, VtCond []Condition, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(MainKey, 2)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtCond)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtCond {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "delSet", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) AddSetBS(ModuleName string, MainKey []int8, MpValue map[string]UpdateValueBS, IExpireTime int32, IVersion int8, BDirty bool, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MainKey)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(MainKey)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.MAP, 3)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MpValue)), 0)
	if err != nil {
		return ret, err
	}
	for k120, v120 := range MpValue {

		err = _os.Write_string(k120, 0)
		if err != nil {
			return ret, err
		}

		err = v120.WriteBlock(_os, 1)
		if err != nil {
			return ret, err
		}
	}

	err = _os.Write_int32(IExpireTime, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int8(IVersion, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool(BDirty, 6)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "addSetBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) DelSetBS(ModuleName string, MainKey []int8, VtCond []ConditionBS, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MainKey)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(MainKey)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtCond)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtCond {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "delSetBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) AddZSet(ModuleName string, MainKey string, MpValue map[string]UpdateValue, Score float64, IExpireTime int32, IVersion int8, BDirty bool, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(MainKey, 2)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.MAP, 3)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MpValue)), 0)
	if err != nil {
		return ret, err
	}
	for k121, v121 := range MpValue {

		err = _os.Write_string(k121, 0)
		if err != nil {
			return ret, err
		}

		err = v121.WriteBlock(_os, 1)
		if err != nil {
			return ret, err
		}
	}

	err = _os.Write_float64(Score, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(IExpireTime, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int8(IVersion, 6)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool(BDirty, 7)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "addZSet", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) IncScoreZSet(ModuleName string, MainKey string, MpValue map[string]UpdateValue, Score float64, IExpireTime int32, IVersion int8, BDirty bool, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(MainKey, 2)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.MAP, 3)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MpValue)), 0)
	if err != nil {
		return ret, err
	}
	for k122, v122 := range MpValue {

		err = _os.Write_string(k122, 0)
		if err != nil {
			return ret, err
		}

		err = v122.WriteBlock(_os, 1)
		if err != nil {
			return ret, err
		}
	}

	err = _os.Write_float64(Score, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(IExpireTime, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int8(IVersion, 6)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool(BDirty, 7)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "incScoreZSet", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) DelZSet(ModuleName string, MainKey string, VtCond []Condition, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(MainKey, 2)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtCond)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtCond {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "delZSet", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) DelRangeZSet(ModuleName string, MainKey string, IMin float64, IMax float64, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(MainKey, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_float64(IMin, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_float64(IMax, 4)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "delRangeZSet", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) AddZSetBS(ModuleName string, MainKey []int8, MpValue map[string]UpdateValueBS, Score float64, IExpireTime int32, IVersion int8, BDirty bool, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MainKey)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(MainKey)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.MAP, 3)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MpValue)), 0)
	if err != nil {
		return ret, err
	}
	for k123, v123 := range MpValue {

		err = _os.Write_string(k123, 0)
		if err != nil {
			return ret, err
		}

		err = v123.WriteBlock(_os, 1)
		if err != nil {
			return ret, err
		}
	}

	err = _os.Write_float64(Score, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(IExpireTime, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int8(IVersion, 6)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool(BDirty, 7)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "addZSetBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) IncScoreZSetBS(ModuleName string, MainKey []int8, MpValue map[string]UpdateValueBS, Score float64, IExpireTime int32, IVersion int8, BDirty bool, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MainKey)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(MainKey)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.MAP, 3)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MpValue)), 0)
	if err != nil {
		return ret, err
	}
	for k124, v124 := range MpValue {

		err = _os.Write_string(k124, 0)
		if err != nil {
			return ret, err
		}

		err = v124.WriteBlock(_os, 1)
		if err != nil {
			return ret, err
		}
	}

	err = _os.Write_float64(Score, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(IExpireTime, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int8(IVersion, 6)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool(BDirty, 7)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "incScoreZSetBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) DelZSetBS(ModuleName string, MainKey []int8, VtCond []ConditionBS, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MainKey)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(MainKey)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.LIST, 3)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(VtCond)), 0)
	if err != nil {
		return ret, err
	}
	for _, v := range VtCond {

		err = v.WriteBlock(_os, 0)
		if err != nil {
			return ret, err
		}
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "delZSetBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) DelRangeZSetBS(ModuleName string, MainKey []int8, IMin float64, IMax float64, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.WriteHead(codec.SIMPLE_LIST, 2)
	if err != nil {
		return ret, err
	}
	err = _os.WriteHead(codec.BYTE, 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_int32(int32(len(MainKey)), 0)
	if err != nil {
		return ret, err
	}
	err = _os.Write_slice_int8(MainKey)
	if err != nil {
		return ret, err
	}

	err = _os.Write_float64(IMin, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_float64(IMax, 4)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "delRangeZSetBS", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}
func (_obj *Proxy) SyncSetBinLog(ModuleName string, Set string, GroupName string, LogContent string, Compress bool, CacheType CacheType, _opt ...map[string]string) (ret int32, err error) {

	var length int32
	var have bool
	var ty byte
	_os := codec.NewBuffer()
	err = _os.Write_string(ModuleName, 1)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(Set, 2)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(GroupName, 3)
	if err != nil {
		return ret, err
	}

	err = _os.Write_string(LogContent, 4)
	if err != nil {
		return ret, err
	}

	err = _os.Write_bool(Compress, 5)
	if err != nil {
		return ret, err
	}

	err = _os.Write_int32(int32(CacheType), 6)
	if err != nil {
		return ret, err
	}

	var _status map[string]string
	var _context map[string]string
	_resp := new(requestf.ResponsePacket)
	err = _obj.s.Taf_invoke(0, "syncSetBinLog", _os.ToBytes(), _status, _context, _resp)
	if err != nil {
		return ret, err
	}
	_is := codec.NewReader(_resp.SBuffer)
	err = _is.Read_int32(&ret, 0, true)
	if err != nil {
		return ret, err
	}

	_ = length
	_ = have
	_ = ty
	return ret, nil
}

func (_obj *Proxy) SetServant(s m.Servant) {
	_obj.s = s
}

func (_obj *Proxy) TarsSetTimeout(t int) {
	_obj.s.TarsSetTimeout(t)
}

func (_obj *Proxy) AddServant(imp _impProxy, obj string) {
	tars.AddServant(_obj, imp, obj)
}

type _impProxy interface {
	GetString(ModuleName string, KeyItem string, Value *string) (ret int32, err error)
	GetInt(ModuleName string, KeyItem int32, Value *string) (ret int32, err error)
	GetLong(ModuleName string, KeyItem int64, Value *string) (ret int32, err error)
	GetStringWithVer(ModuleName string, KeyItem string, Value *string, Ver *int8) (ret int32, err error)
	GetIntWithVer(ModuleName string, KeyItem int32, Value *string, Ver *int8) (ret int32, err error)
	GetLongWithVer(ModuleName string, KeyItem int64, Value *string, Ver *int8) (ret int32, err error)
	GetStringBS(ModuleName string, KeyItem []int8, Value *[]int8) (ret int32, err error)
	GetIntBS(ModuleName string, KeyItem int32, Value *[]int8) (ret int32, err error)
	GetLongBS(ModuleName string, KeyItem int64, Value *[]int8) (ret int32, err error)
	GetStringWithVerBS(ModuleName string, KeyItem []int8, Value *[]int8, Ver *int8) (ret int32, err error)
	GetIntWithVerBS(ModuleName string, KeyItem int32, Value *[]int8, Ver *int8) (ret int32, err error)
	GetLongWithVerBS(ModuleName string, KeyItem int64, Value *[]int8, Ver *int8) (ret int32, err error)
	GetStringBatch(ModuleName string, VtKeyItem []string, VtValue *[]SKeyValue) (ret int32, err error)
	GetIntBatch(ModuleName string, VtKeyItem []int32, VtValue *[]IKeyValue) (ret int32, err error)
	GetLongBatch(ModuleName string, VtKeyItem []int64, VtValue *[]LKeyValue) (ret int32, err error)
	GetStringBatchBS(ModuleName string, VtKeyItem [][]int8, VtValue *[]SKeyValueBS) (ret int32, err error)
	GetIntBatchBS(ModuleName string, VtKeyItem []int32, VtValue *[]IKeyValueBS) (ret int32, err error)
	GetLongBatchBS(ModuleName string, VtKeyItem []int64, VtValue *[]LKeyValueBS) (ret int32, err error)
	CheckString(ModuleName string, KeyItem string) (ret int32, err error)
	CheckInt(ModuleName string, KeyItem int32) (ret int32, err error)
	CheckLong(ModuleName string, KeyItem int64) (ret int32, err error)
	CheckStringBatch(ModuleName string, VtKeyItem []string, MpResult *map[string]int32) (ret int32, err error)
	CheckIntBatch(ModuleName string, VtKeyItem []int32, MpResult *map[int32]int32) (ret int32, err error)
	CheckLongBatch(ModuleName string, VtKeyItem []int64, MpResult *map[int64]int32) (ret int32, err error)
	CheckStringBatchBS(ModuleName string, VtKeyItem [][]int8, MpResult *map[string]int32) (ret int32, err error)
	CheckIntBatchBS(ModuleName string, VtKeyItem []int32, MpResult *map[int32]int32) (ret int32, err error)
	CheckLongBatchBS(ModuleName string, VtKeyItem []int64, MpResult *map[int64]int32) (ret int32, err error)
	SetString(ModuleName string, KeyItem string, Value string) (ret int32, err error)
	SetInt(ModuleName string, KeyItem int32, Value string) (ret int32, err error)
	SetLong(ModuleName string, KeyItem int64, Value string) (ret int32, err error)
	SetStringBS(ModuleName string, KeyItem []int8, Value []int8) (ret int32, err error)
	SetIntBS(ModuleName string, KeyItem int32, Value []int8) (ret int32, err error)
	SetLongBS(ModuleName string, KeyItem int64, Value []int8) (ret int32, err error)
	SetIntBatch(ModuleName string, KeyValue map[int32]string, KeyResult *map[int32]int32) (ret int32, err error)
	SetLongBatch(ModuleName string, KeyValue map[int64]string, KeyResult *map[int64]int32) (ret int32, err error)
	SetStringBatch(ModuleName string, KeyValue map[string]string, KeyResult *map[string]int32) (ret int32, err error)
	SetIntBatchBS(ModuleName string, KeyValue map[int32][]int8, KeyResult *map[int32]int32) (ret int32, err error)
	SetLongBatchBS(ModuleName string, KeyValue map[int64][]int8, KeyResult *map[int64]int32) (ret int32, err error)
	SetStringBatchBS(ModuleName string, KeyValue []SSetKeyValueBS, KeyResult *[]SSetKeyResultBS) (ret int32, err error)
	SetStringWithDirty(ModuleName string, KeyItem string, Value string, Dirty bool) (ret int32, err error)
	SetIntWithDirty(ModuleName string, KeyItem int32, Value string, Dirty bool) (ret int32, err error)
	SetLongWithDirty(ModuleName string, KeyItem int64, Value string, Dirty bool) (ret int32, err error)
	SetStringWithDirtyBS(ModuleName string, KeyItem []int8, Value []int8, Dirty bool) (ret int32, err error)
	SetIntWithDirtyBS(ModuleName string, KeyItem int32, Value []int8, Dirty bool) (ret int32, err error)
	SetLongWithDirtyBS(ModuleName string, KeyItem int64, Value []int8, Dirty bool) (ret int32, err error)
	SetStringEx(ModuleName string, KeyItem string, Value string, Ver int8, Dirty bool, ExpireTimeSecond int32) (ret int32, err error)
	SetIntEx(ModuleName string, KeyItem int32, Value string, Ver int8, Dirty bool, ExpireTimeSecond int32) (ret int32, err error)
	SetLongEx(ModuleName string, KeyItem int64, Value string, Ver int8, Dirty bool, ExpireTimeSecond int32) (ret int32, err error)
	SetStringExBS(ModuleName string, KeyItem []int8, Value []int8, Ver int8, Dirty bool, ExpireTimeSecond int32) (ret int32, err error)
	SetIntExBS(ModuleName string, KeyItem int32, Value []int8, Ver int8, Dirty bool, ExpireTimeSecond int32) (ret int32, err error)
	SetLongExBS(ModuleName string, KeyItem int64, Value []int8, Ver int8, Dirty bool, ExpireTimeSecond int32) (ret int32, err error)
	SetStringExBatch(ModuleName string, KeyValue []SSetKeyValue, KeyResult *map[string]int32) (ret int32, err error)
	SetIntExBatch(ModuleName string, KeyValue []ISetKeyValue, KeyResult *map[int32]int32) (ret int32, err error)
	SetLongExBatch(ModuleName string, KeyValue []LSetKeyValue, KeyResult *map[int64]int32) (ret int32, err error)
	SetStringExBatchBS(ModuleName string, KeyValue []SSetKeyValueBS, KeyResult *[]SSetKeyResultBS) (ret int32, err error)
	SetIntExBatchBS(ModuleName string, KeyValue []ISetKeyValueBS, KeyResult *map[int32]int32) (ret int32, err error)
	SetLongExBatchBS(ModuleName string, KeyValue []LSetKeyValueBS, KeyResult *map[int64]int32) (ret int32, err error)
	UpdateIntEx(ModuleName string, KeyItem int32, Value string, Dirty bool, ExpireTimeSecond int32, Option Op, RetValue *string) (ret int32, err error)
	UpdateIntExBS(ModuleName string, KeyItem int32, Value []int8, Dirty bool, ExpireTimeSecond int32, Option Op, RetValue *[]int8) (ret int32, err error)
	UpdateLongEx(ModuleName string, KeyItem int64, Value string, Dirty bool, ExpireTimeSecond int32, Option Op, RetValue *string) (ret int32, err error)
	UpdateLongExBS(ModuleName string, KeyItem int64, Value []int8, Dirty bool, ExpireTimeSecond int32, Option Op, RetValue *[]int8) (ret int32, err error)
	UpdateStringEx(ModuleName string, KeyItem string, Value string, Dirty bool, ExpireTimeSecond int32, Option Op, RetValue *string) (ret int32, err error)
	UpdateStringExBS(ModuleName string, KeyItem []int8, Value []int8, Dirty bool, ExpireTimeSecond int32, Option Op, RetValue *[]int8) (ret int32, err error)
	EraseString(ModuleName string, KeyItem string) (ret int32, err error)
	EraseInt(ModuleName string, KeyItem int32) (ret int32, err error)
	EraseLong(ModuleName string, KeyItem int64) (ret int32, err error)
	EraseStringBatch(ModuleName string, KeyItem map[string]int8, KeyResult *map[string]int32) (ret int32, err error)
	EraseIntBatch(ModuleName string, KeyItem map[int32]int8, KeyResult *map[int32]int32) (ret int32, err error)
	EraseLongBatch(ModuleName string, KeyItem map[int64]int8, KeyResult *map[int64]int32) (ret int32, err error)
	EraseStringBatchBS(ModuleName string, KeyItem []SKeyVersionBS, KeyResult *[]SKeyResultBS) (ret int32, err error)
	EraseStringBS(ModuleName string, KeyItem []int8) (ret int32, err error)
	DelString(ModuleName string, KeyItem string) (ret int32, err error)
	DelInt(ModuleName string, KeyItem int32) (ret int32, err error)
	DelLong(ModuleName string, KeyItem int64) (ret int32, err error)
	DelStringBatch(ModuleName string, KeyItem map[string]int8, KeyResult *map[string]int32) (ret int32, err error)
	DelIntBatch(ModuleName string, KeyItem map[int32]int8, KeyResult *map[int32]int32) (ret int32, err error)
	DelLongBatch(ModuleName string, KeyItem map[int64]int8, KeyResult *map[int64]int32) (ret int32, err error)
	DelStringBatchBS(ModuleName string, KeyItem []SKeyVersionBS, KeyResult *[]SKeyResultBS) (ret int32, err error)
	DelStringBS(ModuleName string, KeyItem []int8) (ret int32, err error)
	GetAllMainKey(ModuleName string, Index int32, Count int32, MainKey *[]string, IsEnd *bool) (ret int32, err error)
	Select(ModuleName string, MainIndex string, Field string, VtCond []Condition, VtData *[]map[string]string) (ret int32, err error)
	SelectBS(ModuleName string, MainIndex []int8, Field string, VtCond []ConditionBS, VtData *[]map[string][]int8) (ret int32, err error)
	SelectEx(ModuleName string, MainIndex string, Field string, VtCond []Condition, BGetMKCout bool, VtData *[]map[string]string) (ret int32, err error)
	SelectBSEx(ModuleName string, MainIndex []int8, Field string, VtCond []ConditionBS, BGetMKCout bool, VtData *[]map[string][]int8) (ret int32, err error)
	SelectBin(ModuleName string, MainKey string, VtCond []Condition, BGetMKCout bool, VtData *[]int8) (ret int32, err error)
	SelectByPos(ModuleName string, MainIndex string, Field string, VtCond []Condition, ICount uint32, DirectionType DirectionType, VtData *[]map[string]string) (ret int32, err error)
	SelectBatch(ModuleName string, VtMainKey []string, Field string, VtCond []Condition, VtData *[]MainKeyValue) (ret int32, err error)
	SelectBatchBS(ModuleName string, VtMainKey [][]int8, Field string, VtCond []ConditionBS, VtData *[]MainKeyValueBS) (ret int32, err error)
	SelectBinBatch(ModuleName string, VtMainKey []string, VtCond []Condition, VtData *[]MainKeyValueBin) (ret int32, err error)
	SelectBatchEx(ModuleName string, VtMUKey []Record, Field string, VtData *[]Record) (ret int32, err error)
	SelectBatchExBS(ModuleName string, VtMUKey []RecordBS, Field string, VtData *[]RecordBS) (ret int32, err error)
	SelectBatchOr(ModuleName string, VtKey []MainKeyCondition, VtData *[]MainKeyValue) (ret int32, err error)
	SelectBatchOrBS(ModuleName string, VtKey []MainKeyConditionBS, VtData *[]MainKeyValueBS) (ret int32, err error)
	Insert(ModuleName string, MainIndex string, MpValue map[string]UpdateValue, Replace bool) (ret int32, err error)
	InsertBS(ModuleName string, MainIndex []int8, MpValue map[string]UpdateValueBS, Replace bool) (ret int32, err error)
	InsertEx(ModuleName string, MainIndex string, MpValue map[string]UpdateValue, Ver int8, Dirty bool, Replace bool, ExpireTimeSecond int32) (ret int32, err error)
	InsertBSEx(ModuleName string, MainIndex []int8, MpValue map[string]UpdateValueBS, Ver int8, Dirty bool, Replace bool, ExpireTimeSecond int32) (ret int32, err error)
	InsertBatch(ModuleName string, VtKeyValue []InsertKeyValue, MpFailIndexReason *map[int32]int32) (ret int32, err error)
	InsertBatchBS(ModuleName string, VtKeyValue []InsertKeyValueBS, MpFailIndexReason *map[int32]int32) (ret int32, err error)
	Update(ModuleName string, MainIndex string, MpValue map[string]UpdateValue, VtCond []Condition) (ret int32, err error)
	UpdateBS(ModuleName string, MainIndex []int8, MpValue map[string]UpdateValueBS, VtCond []ConditionBS) (ret int32, err error)
	UpdateEx(ModuleName string, MainIndex string, MpValue map[string]UpdateValue, VtCond []Condition, Ver int8, Dirty bool, ExpireTimeSecond int32) (ret int32, err error)
	UpdateBSEx(ModuleName string, MainIndex []int8, MpValue map[string]UpdateValueBS, VtCond []ConditionBS, Ver int8, Dirty bool, ExpireTimeSecond int32) (ret int32, err error)
	UpdateAtom(ModuleName string, MainIndex string, MpValue map[string]UpdateValue, VtCond []Condition, Dirty bool, ExpireTimeSecond int32) (ret int32, err error)
	UpdateBSAtom(ModuleName string, MainIndex []int8, MpValue map[string]UpdateValueBS, VtCond []ConditionBS, Dirty bool, ExpireTimeSecond int32) (ret int32, err error)
	UpdateBatch(ModuleName string, VtKeyValue []UpdateKeyValue, MpFailIndexReason *map[int32]int32) (ret int32, err error)
	UpdateBatchBS(ModuleName string, VtKeyValue []UpdateKeyValueBS, MpFailIndexReason *map[int32]int32) (ret int32, err error)
	Erase(ModuleName string, MainIndex string) (ret int32, err error)
	EraseBS(ModuleName string, MainIndex []int8) (ret int32, err error)
	Del(ModuleName string, MainIndex string, VtCond []Condition) (ret int32, err error)
	DelBatch(ModuleName string, VtCond []DelCondition, MRet *map[int32]int32) (ret int32, err error)
	DelBS(ModuleName string, MainIndex []int8, VtCond []ConditionBS) (ret int32, err error)
	GetMainKeyCount(ModuleName string, MainKey string) (ret int32, err error)
	GetMKAllMainKey(ModuleName string, Index int32, Count int32, MainKey *[]string, IsEnd *bool) (ret int32, err error)
	GetRangeList(ModuleName string, MainKey string, Field string, IStart int64, IEnd int64, VtData *[]map[string]string) (ret int32, err error)
	GetRangeListBS(ModuleName string, MainKey []int8, Field string, IStart int64, IEnd int64, VtData *[]map[string][]int8) (ret int32, err error)
	GetList(ModuleName string, MainKey string, Field string, IPos int64, MData *map[string]string) (ret int32, err error)
	GetListBS(ModuleName string, MainKey []int8, Field string, IPos int64, MData *map[string][]int8) (ret int32, err error)
	GetSet(ModuleName string, MainKey string, Field string, VtData *[]map[string]string) (ret int32, err error)
	GetSetBS(ModuleName string, MainKey []int8, Field string, VtData *[]map[string][]int8) (ret int32, err error)
	GetScoreZSet(ModuleName string, MainKey string, VtCond []Condition, IScore *float64) (ret int32, err error)
	GetRankZSet(ModuleName string, MainKey string, VtCond []Condition, BOrder bool, IPos *int64) (ret int32, err error)
	GetRangeZSet(ModuleName string, MainKey string, Field string, IStart int64, IEnd int64, BUp bool, VtData *[]map[string]string) (ret int32, err error)
	SelectZSetBatch(ModuleName string, VtMainKey []string, Field string, VtCond []Condition, VtData *[]MainKeyValue) (ret int32, err error)
	GetRangeZSetByScore(ModuleName string, MainKey string, Field string, IMin float64, IMax float64, VtData *[]map[string]string) (ret int32, err error)
	SelectZSetBatchBS(ModuleName string, VtMainKey [][]int8, Field string, VtCond []ConditionBS, VtData *[]MainKeyValueBS) (ret int32, err error)
	GetScoreZSetBS(ModuleName string, MainKey []int8, VtCond []ConditionBS, IScore *float64) (ret int32, err error)
	GetRankZSetBS(ModuleName string, MainKey []int8, VtCond []ConditionBS, BOrder bool, IPos *int64) (ret int32, err error)
	GetRangeZSetBS(ModuleName string, MainKey []int8, Field string, IStart int64, IEnd int64, BUp bool, VtData *[]map[string][]int8) (ret int32, err error)
	GetRangeZSetByScoreBS(ModuleName string, MainKey []int8, Field string, IMin float64, IMax float64, VtData *[]map[string][]int8) (ret int32, err error)
	PushList(ModuleName string, MainKey string, MpValue []InsertKeyValue, BHead bool) (ret int32, err error)
	PopList(ModuleName string, MainKey string, BHead bool, Value *map[string]string) (ret int32, err error)
	ReplaceList(ModuleName string, MainKey string, MpValue map[string]UpdateValue, IPos int64, IExpireTime int32) (ret int32, err error)
	TrimList(ModuleName string, MainKey string, IStart int64, IEnd int64) (ret int32, err error)
	RemList(ModuleName string, MainKey string, BHead bool, ICount int64) (ret int32, err error)
	PushListBS(ModuleName string, MainKey []int8, MpValue []InsertKeyValueBS, BHead bool) (ret int32, err error)
	PopListBS(ModuleName string, MainKey []int8, BHead bool, Value *map[string][]int8) (ret int32, err error)
	ReplaceListBS(ModuleName string, MainKey []int8, MpValue map[string]UpdateValueBS, IPos int64, IExpireTime int32) (ret int32, err error)
	TrimListBS(ModuleName string, MainKey []int8, IStart int64, IEnd int64) (ret int32, err error)
	RemListBS(ModuleName string, MainKey []int8, BHead bool, ICount int64) (ret int32, err error)
	AddSet(ModuleName string, MainKey string, MpValue map[string]UpdateValue, IExpireTime int32, IVersion int8, BDirty bool) (ret int32, err error)
	DelSet(ModuleName string, MainKey string, VtCond []Condition) (ret int32, err error)
	AddSetBS(ModuleName string, MainKey []int8, MpValue map[string]UpdateValueBS, IExpireTime int32, IVersion int8, BDirty bool) (ret int32, err error)
	DelSetBS(ModuleName string, MainKey []int8, VtCond []ConditionBS) (ret int32, err error)
	AddZSet(ModuleName string, MainKey string, MpValue map[string]UpdateValue, Score float64, IExpireTime int32, IVersion int8, BDirty bool) (ret int32, err error)
	IncScoreZSet(ModuleName string, MainKey string, MpValue map[string]UpdateValue, Score float64, IExpireTime int32, IVersion int8, BDirty bool) (ret int32, err error)
	DelZSet(ModuleName string, MainKey string, VtCond []Condition) (ret int32, err error)
	DelRangeZSet(ModuleName string, MainKey string, IMin float64, IMax float64) (ret int32, err error)
	AddZSetBS(ModuleName string, MainKey []int8, MpValue map[string]UpdateValueBS, Score float64, IExpireTime int32, IVersion int8, BDirty bool) (ret int32, err error)
	IncScoreZSetBS(ModuleName string, MainKey []int8, MpValue map[string]UpdateValueBS, Score float64, IExpireTime int32, IVersion int8, BDirty bool) (ret int32, err error)
	DelZSetBS(ModuleName string, MainKey []int8, VtCond []ConditionBS) (ret int32, err error)
	DelRangeZSetBS(ModuleName string, MainKey []int8, IMin float64, IMax float64) (ret int32, err error)
	SyncSetBinLog(ModuleName string, Set string, GroupName string, LogContent string, Compress bool, CacheType CacheType) (ret int32, err error)
}

func (_obj *Proxy) Dispatch(_val interface{}, req *requestf.RequestPacket, resp *requestf.ResponsePacket) (err error) {
	var length int32
	var have bool
	var ty byte
	_is := codec.NewReader(req.SBuffer)
	_os := codec.NewBuffer()
	_imp := _val.(_impProxy)
	switch req.SFuncName {
	case "getString":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem string
		err = _is.Read_string(&KeyItem, 2, true)
		if err != nil {
			return err
		}
		var Value string
		ret, err := _imp.GetString(ModuleName, KeyItem, &Value)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.Write_string(Value, 3)
		if err != nil {
			return err
		}
	case "getInt":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem int32
		err = _is.Read_int32(&KeyItem, 2, true)
		if err != nil {
			return err
		}
		var Value string
		ret, err := _imp.GetInt(ModuleName, KeyItem, &Value)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.Write_string(Value, 3)
		if err != nil {
			return err
		}
	case "getLong":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem int64
		err = _is.Read_int64(&KeyItem, 2, true)
		if err != nil {
			return err
		}
		var Value string
		ret, err := _imp.GetLong(ModuleName, KeyItem, &Value)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.Write_string(Value, 3)
		if err != nil {
			return err
		}
	case "getStringWithVer":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem string
		err = _is.Read_string(&KeyItem, 2, true)
		if err != nil {
			return err
		}
		var Value string
		var Ver int8
		ret, err := _imp.GetStringWithVer(ModuleName, KeyItem, &Value, &Ver)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.Write_string(Value, 3)
		if err != nil {
			return err
		}

		err = _os.Write_int8(Ver, 4)
		if err != nil {
			return err
		}
	case "getIntWithVer":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem int32
		err = _is.Read_int32(&KeyItem, 2, true)
		if err != nil {
			return err
		}
		var Value string
		var Ver int8
		ret, err := _imp.GetIntWithVer(ModuleName, KeyItem, &Value, &Ver)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.Write_string(Value, 3)
		if err != nil {
			return err
		}

		err = _os.Write_int8(Ver, 4)
		if err != nil {
			return err
		}
	case "getLongWithVer":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem int64
		err = _is.Read_int64(&KeyItem, 2, true)
		if err != nil {
			return err
		}
		var Value string
		var Ver int8
		ret, err := _imp.GetLongWithVer(ModuleName, KeyItem, &Value, &Ver)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.Write_string(Value, 3)
		if err != nil {
			return err
		}

		err = _os.Write_int8(Ver, 4)
		if err != nil {
			return err
		}
	case "getStringBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem []int8
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			KeyItem = make([]int8, length, length)
			for i125, e125 := int32(0), length; i125 < e125; i125++ {

				err = _is.Read_int8(&KeyItem[i125], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&KeyItem, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var Value []int8
		ret, err := _imp.GetStringBS(ModuleName, KeyItem, &Value)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.SIMPLE_LIST, 3)
		if err != nil {
			return err
		}
		err = _os.WriteHead(codec.BYTE, 0)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(Value)), 0)
		if err != nil {
			return err
		}
		err = _os.Write_slice_int8(Value)
		if err != nil {
			return err
		}
	case "getIntBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem int32
		err = _is.Read_int32(&KeyItem, 2, true)
		if err != nil {
			return err
		}
		var Value []int8
		ret, err := _imp.GetIntBS(ModuleName, KeyItem, &Value)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.SIMPLE_LIST, 3)
		if err != nil {
			return err
		}
		err = _os.WriteHead(codec.BYTE, 0)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(Value)), 0)
		if err != nil {
			return err
		}
		err = _os.Write_slice_int8(Value)
		if err != nil {
			return err
		}
	case "getLongBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem int64
		err = _is.Read_int64(&KeyItem, 2, true)
		if err != nil {
			return err
		}
		var Value []int8
		ret, err := _imp.GetLongBS(ModuleName, KeyItem, &Value)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.SIMPLE_LIST, 3)
		if err != nil {
			return err
		}
		err = _os.WriteHead(codec.BYTE, 0)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(Value)), 0)
		if err != nil {
			return err
		}
		err = _os.Write_slice_int8(Value)
		if err != nil {
			return err
		}
	case "getStringWithVerBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem []int8
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			KeyItem = make([]int8, length, length)
			for i126, e126 := int32(0), length; i126 < e126; i126++ {

				err = _is.Read_int8(&KeyItem[i126], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&KeyItem, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var Value []int8
		var Ver int8
		ret, err := _imp.GetStringWithVerBS(ModuleName, KeyItem, &Value, &Ver)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.SIMPLE_LIST, 3)
		if err != nil {
			return err
		}
		err = _os.WriteHead(codec.BYTE, 0)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(Value)), 0)
		if err != nil {
			return err
		}
		err = _os.Write_slice_int8(Value)
		if err != nil {
			return err
		}

		err = _os.Write_int8(Ver, 4)
		if err != nil {
			return err
		}
	case "getIntWithVerBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem int32
		err = _is.Read_int32(&KeyItem, 2, true)
		if err != nil {
			return err
		}
		var Value []int8
		var Ver int8
		ret, err := _imp.GetIntWithVerBS(ModuleName, KeyItem, &Value, &Ver)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.SIMPLE_LIST, 3)
		if err != nil {
			return err
		}
		err = _os.WriteHead(codec.BYTE, 0)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(Value)), 0)
		if err != nil {
			return err
		}
		err = _os.Write_slice_int8(Value)
		if err != nil {
			return err
		}

		err = _os.Write_int8(Ver, 4)
		if err != nil {
			return err
		}
	case "getLongWithVerBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem int64
		err = _is.Read_int64(&KeyItem, 2, true)
		if err != nil {
			return err
		}
		var Value []int8
		var Ver int8
		ret, err := _imp.GetLongWithVerBS(ModuleName, KeyItem, &Value, &Ver)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.SIMPLE_LIST, 3)
		if err != nil {
			return err
		}
		err = _os.WriteHead(codec.BYTE, 0)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(Value)), 0)
		if err != nil {
			return err
		}
		err = _os.Write_slice_int8(Value)
		if err != nil {
			return err
		}

		err = _os.Write_int8(Ver, 4)
		if err != nil {
			return err
		}
	case "getStringBatch":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var VtKeyItem []string
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtKeyItem = make([]string, length, length)
			for i127, e127 := int32(0), length; i127 < e127; i127++ {

				err = _is.Read_string(&VtKeyItem[i127], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var VtValue []SKeyValue
		ret, err := _imp.GetStringBatch(ModuleName, VtKeyItem, &VtValue)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 3)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(VtValue)), 0)
		if err != nil {
			return err
		}
		for _, v := range VtValue {

			err = v.WriteBlock(_os, 0)
			if err != nil {
				return err
			}
		}
	case "getIntBatch":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var VtKeyItem []int32
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtKeyItem = make([]int32, length, length)
			for i128, e128 := int32(0), length; i128 < e128; i128++ {

				err = _is.Read_int32(&VtKeyItem[i128], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var VtValue []IKeyValue
		ret, err := _imp.GetIntBatch(ModuleName, VtKeyItem, &VtValue)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 3)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(VtValue)), 0)
		if err != nil {
			return err
		}
		for _, v := range VtValue {

			err = v.WriteBlock(_os, 0)
			if err != nil {
				return err
			}
		}
	case "getLongBatch":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var VtKeyItem []int64
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtKeyItem = make([]int64, length, length)
			for i129, e129 := int32(0), length; i129 < e129; i129++ {

				err = _is.Read_int64(&VtKeyItem[i129], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var VtValue []LKeyValue
		ret, err := _imp.GetLongBatch(ModuleName, VtKeyItem, &VtValue)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 3)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(VtValue)), 0)
		if err != nil {
			return err
		}
		for _, v := range VtValue {

			err = v.WriteBlock(_os, 0)
			if err != nil {
				return err
			}
		}
	case "getStringBatchBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var VtKeyItem [][]int8
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtKeyItem = make([][]int8, length, length)
			for i130, e130 := int32(0), length; i130 < e130; i130++ {

				err, have, ty = _is.SkipToNoCheck(0, false)
				if err != nil {
					return err
				}
				if have {
					if ty == codec.LIST {
						err = _is.Read_int32(&length, 0, true)
						if err != nil {
							return err
						}
						VtKeyItem[i130] = make([]int8, length, length)
						for i131, e131 := int32(0), length; i131 < e131; i131++ {

							err = _is.Read_int8(&VtKeyItem[i130][i131], 0, false)
							if err != nil {
								return err
							}
						}
					} else if ty == codec.SIMPLE_LIST {

						err, _ = _is.SkipTo(codec.BYTE, 0, true)
						if err != nil {
							return err
						}
						err = _is.Read_int32(&length, 0, true)
						if err != nil {
							return err
						}
						err = _is.Read_slice_int8(&VtKeyItem[i130], length, true)
						if err != nil {
							return err
						}

					} else {
						err = fmt.Errorf("require vector, but not.")
						if err != nil {
							return err
						}
					}
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var VtValue []SKeyValueBS
		ret, err := _imp.GetStringBatchBS(ModuleName, VtKeyItem, &VtValue)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 3)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(VtValue)), 0)
		if err != nil {
			return err
		}
		for _, v := range VtValue {

			err = v.WriteBlock(_os, 0)
			if err != nil {
				return err
			}
		}
	case "getIntBatchBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var VtKeyItem []int32
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtKeyItem = make([]int32, length, length)
			for i132, e132 := int32(0), length; i132 < e132; i132++ {

				err = _is.Read_int32(&VtKeyItem[i132], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var VtValue []IKeyValueBS
		ret, err := _imp.GetIntBatchBS(ModuleName, VtKeyItem, &VtValue)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 3)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(VtValue)), 0)
		if err != nil {
			return err
		}
		for _, v := range VtValue {

			err = v.WriteBlock(_os, 0)
			if err != nil {
				return err
			}
		}
	case "getLongBatchBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var VtKeyItem []int64
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtKeyItem = make([]int64, length, length)
			for i133, e133 := int32(0), length; i133 < e133; i133++ {

				err = _is.Read_int64(&VtKeyItem[i133], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var VtValue []LKeyValueBS
		ret, err := _imp.GetLongBatchBS(ModuleName, VtKeyItem, &VtValue)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 3)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(VtValue)), 0)
		if err != nil {
			return err
		}
		for _, v := range VtValue {

			err = v.WriteBlock(_os, 0)
			if err != nil {
				return err
			}
		}
	case "checkString":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem string
		err = _is.Read_string(&KeyItem, 2, true)
		if err != nil {
			return err
		}
		ret, err := _imp.CheckString(ModuleName, KeyItem)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "checkInt":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem int32
		err = _is.Read_int32(&KeyItem, 2, true)
		if err != nil {
			return err
		}
		ret, err := _imp.CheckInt(ModuleName, KeyItem)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "checkLong":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem int64
		err = _is.Read_int64(&KeyItem, 2, true)
		if err != nil {
			return err
		}
		ret, err := _imp.CheckLong(ModuleName, KeyItem)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "checkStringBatch":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var VtKeyItem []string
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtKeyItem = make([]string, length, length)
			for i134, e134 := int32(0), length; i134 < e134; i134++ {

				err = _is.Read_string(&VtKeyItem[i134], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var MpResult map[string]int32
		ret, err := _imp.CheckStringBatch(ModuleName, VtKeyItem, &MpResult)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.MAP, 3)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(MpResult)), 0)
		if err != nil {
			return err
		}
		for k135, v135 := range MpResult {

			err = _os.Write_string(k135, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(v135, 1)
			if err != nil {
				return err
			}
		}
	case "checkIntBatch":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var VtKeyItem []int32
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtKeyItem = make([]int32, length, length)
			for i136, e136 := int32(0), length; i136 < e136; i136++ {

				err = _is.Read_int32(&VtKeyItem[i136], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var MpResult map[int32]int32
		ret, err := _imp.CheckIntBatch(ModuleName, VtKeyItem, &MpResult)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.MAP, 3)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(MpResult)), 0)
		if err != nil {
			return err
		}
		for k137, v137 := range MpResult {

			err = _os.Write_int32(k137, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(v137, 1)
			if err != nil {
				return err
			}
		}
	case "checkLongBatch":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var VtKeyItem []int64
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtKeyItem = make([]int64, length, length)
			for i138, e138 := int32(0), length; i138 < e138; i138++ {

				err = _is.Read_int64(&VtKeyItem[i138], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var MpResult map[int64]int32
		ret, err := _imp.CheckLongBatch(ModuleName, VtKeyItem, &MpResult)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.MAP, 3)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(MpResult)), 0)
		if err != nil {
			return err
		}
		for k139, v139 := range MpResult {

			err = _os.Write_int64(k139, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(v139, 1)
			if err != nil {
				return err
			}
		}
	case "checkStringBatchBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var VtKeyItem [][]int8
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtKeyItem = make([][]int8, length, length)
			for i140, e140 := int32(0), length; i140 < e140; i140++ {

				err, have, ty = _is.SkipToNoCheck(0, false)
				if err != nil {
					return err
				}
				if have {
					if ty == codec.LIST {
						err = _is.Read_int32(&length, 0, true)
						if err != nil {
							return err
						}
						VtKeyItem[i140] = make([]int8, length, length)
						for i141, e141 := int32(0), length; i141 < e141; i141++ {

							err = _is.Read_int8(&VtKeyItem[i140][i141], 0, false)
							if err != nil {
								return err
							}
						}
					} else if ty == codec.SIMPLE_LIST {

						err, _ = _is.SkipTo(codec.BYTE, 0, true)
						if err != nil {
							return err
						}
						err = _is.Read_int32(&length, 0, true)
						if err != nil {
							return err
						}
						err = _is.Read_slice_int8(&VtKeyItem[i140], length, true)
						if err != nil {
							return err
						}

					} else {
						err = fmt.Errorf("require vector, but not.")
						if err != nil {
							return err
						}
					}
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var MpResult map[string]int32
		ret, err := _imp.CheckStringBatchBS(ModuleName, VtKeyItem, &MpResult)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.MAP, 3)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(MpResult)), 0)
		if err != nil {
			return err
		}
		for k142, v142 := range MpResult {

			err = _os.Write_string(k142, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(v142, 1)
			if err != nil {
				return err
			}
		}
	case "checkIntBatchBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var VtKeyItem []int32
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtKeyItem = make([]int32, length, length)
			for i143, e143 := int32(0), length; i143 < e143; i143++ {

				err = _is.Read_int32(&VtKeyItem[i143], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var MpResult map[int32]int32
		ret, err := _imp.CheckIntBatchBS(ModuleName, VtKeyItem, &MpResult)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.MAP, 3)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(MpResult)), 0)
		if err != nil {
			return err
		}
		for k144, v144 := range MpResult {

			err = _os.Write_int32(k144, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(v144, 1)
			if err != nil {
				return err
			}
		}
	case "checkLongBatchBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var VtKeyItem []int64
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtKeyItem = make([]int64, length, length)
			for i145, e145 := int32(0), length; i145 < e145; i145++ {

				err = _is.Read_int64(&VtKeyItem[i145], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var MpResult map[int64]int32
		ret, err := _imp.CheckLongBatchBS(ModuleName, VtKeyItem, &MpResult)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.MAP, 3)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(MpResult)), 0)
		if err != nil {
			return err
		}
		for k146, v146 := range MpResult {

			err = _os.Write_int64(k146, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(v146, 1)
			if err != nil {
				return err
			}
		}
	case "setString":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem string
		err = _is.Read_string(&KeyItem, 2, true)
		if err != nil {
			return err
		}
		var Value string
		err = _is.Read_string(&Value, 3, true)
		if err != nil {
			return err
		}
		ret, err := _imp.SetString(ModuleName, KeyItem, Value)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "setInt":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem int32
		err = _is.Read_int32(&KeyItem, 2, true)
		if err != nil {
			return err
		}
		var Value string
		err = _is.Read_string(&Value, 3, true)
		if err != nil {
			return err
		}
		ret, err := _imp.SetInt(ModuleName, KeyItem, Value)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "setLong":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem int64
		err = _is.Read_int64(&KeyItem, 2, true)
		if err != nil {
			return err
		}
		var Value string
		err = _is.Read_string(&Value, 3, true)
		if err != nil {
			return err
		}
		ret, err := _imp.SetLong(ModuleName, KeyItem, Value)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "setStringBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem []int8
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			KeyItem = make([]int8, length, length)
			for i147, e147 := int32(0), length; i147 < e147; i147++ {

				err = _is.Read_int8(&KeyItem[i147], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&KeyItem, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var Value []int8
		err, have, ty = _is.SkipToNoCheck(3, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			Value = make([]int8, length, length)
			for i148, e148 := int32(0), length; i148 < e148; i148++ {

				err = _is.Read_int8(&Value[i148], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&Value, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		ret, err := _imp.SetStringBS(ModuleName, KeyItem, Value)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "setIntBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem int32
		err = _is.Read_int32(&KeyItem, 2, true)
		if err != nil {
			return err
		}
		var Value []int8
		err, have, ty = _is.SkipToNoCheck(3, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			Value = make([]int8, length, length)
			for i149, e149 := int32(0), length; i149 < e149; i149++ {

				err = _is.Read_int8(&Value[i149], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&Value, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		ret, err := _imp.SetIntBS(ModuleName, KeyItem, Value)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "setLongBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem int64
		err = _is.Read_int64(&KeyItem, 2, true)
		if err != nil {
			return err
		}
		var Value []int8
		err, have, ty = _is.SkipToNoCheck(3, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			Value = make([]int8, length, length)
			for i150, e150 := int32(0), length; i150 < e150; i150++ {

				err = _is.Read_int8(&Value[i150], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&Value, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		ret, err := _imp.SetLongBS(ModuleName, KeyItem, Value)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "setIntBatch":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyValue map[int32]string
		err, have = _is.SkipTo(codec.MAP, 2, true)
		if err != nil {
			return err
		}

		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}
		KeyValue = make(map[int32]string)
		for i151, e151 := int32(0), length; i151 < e151; i151++ {
			var k151 int32
			var v151 string

			err = _is.Read_int32(&k151, 0, false)
			if err != nil {
				return err
			}

			err = _is.Read_string(&v151, 1, false)
			if err != nil {
				return err
			}

			KeyValue[k151] = v151
		}
		var KeyResult map[int32]int32
		ret, err := _imp.SetIntBatch(ModuleName, KeyValue, &KeyResult)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.MAP, 3)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(KeyResult)), 0)
		if err != nil {
			return err
		}
		for k152, v152 := range KeyResult {

			err = _os.Write_int32(k152, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(v152, 1)
			if err != nil {
				return err
			}
		}
	case "setLongBatch":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyValue map[int64]string
		err, have = _is.SkipTo(codec.MAP, 2, true)
		if err != nil {
			return err
		}

		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}
		KeyValue = make(map[int64]string)
		for i153, e153 := int32(0), length; i153 < e153; i153++ {
			var k153 int64
			var v153 string

			err = _is.Read_int64(&k153, 0, false)
			if err != nil {
				return err
			}

			err = _is.Read_string(&v153, 1, false)
			if err != nil {
				return err
			}

			KeyValue[k153] = v153
		}
		var KeyResult map[int64]int32
		ret, err := _imp.SetLongBatch(ModuleName, KeyValue, &KeyResult)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.MAP, 3)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(KeyResult)), 0)
		if err != nil {
			return err
		}
		for k154, v154 := range KeyResult {

			err = _os.Write_int64(k154, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(v154, 1)
			if err != nil {
				return err
			}
		}
	case "setStringBatch":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyValue map[string]string
		err, have = _is.SkipTo(codec.MAP, 2, true)
		if err != nil {
			return err
		}

		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}
		KeyValue = make(map[string]string)
		for i155, e155 := int32(0), length; i155 < e155; i155++ {
			var k155 string
			var v155 string

			err = _is.Read_string(&k155, 0, false)
			if err != nil {
				return err
			}

			err = _is.Read_string(&v155, 1, false)
			if err != nil {
				return err
			}

			KeyValue[k155] = v155
		}
		var KeyResult map[string]int32
		ret, err := _imp.SetStringBatch(ModuleName, KeyValue, &KeyResult)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.MAP, 3)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(KeyResult)), 0)
		if err != nil {
			return err
		}
		for k156, v156 := range KeyResult {

			err = _os.Write_string(k156, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(v156, 1)
			if err != nil {
				return err
			}
		}
	case "setIntBatchBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyValue map[int32][]int8
		err, have = _is.SkipTo(codec.MAP, 2, true)
		if err != nil {
			return err
		}

		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}
		KeyValue = make(map[int32][]int8)
		for i157, e157 := int32(0), length; i157 < e157; i157++ {
			var k157 int32
			var v157 []int8

			err = _is.Read_int32(&k157, 0, false)
			if err != nil {
				return err
			}

			err, have, ty = _is.SkipToNoCheck(1, false)
			if err != nil {
				return err
			}
			if have {
				if ty == codec.LIST {
					err = _is.Read_int32(&length, 0, true)
					if err != nil {
						return err
					}
					v157 = make([]int8, length, length)
					for i158, e158 := int32(0), length; i158 < e158; i158++ {

						err = _is.Read_int8(&v157[i158], 0, false)
						if err != nil {
							return err
						}
					}
				} else if ty == codec.SIMPLE_LIST {

					err, _ = _is.SkipTo(codec.BYTE, 0, true)
					if err != nil {
						return err
					}
					err = _is.Read_int32(&length, 0, true)
					if err != nil {
						return err
					}
					err = _is.Read_slice_int8(&v157, length, true)
					if err != nil {
						return err
					}

				} else {
					err = fmt.Errorf("require vector, but not.")
					if err != nil {
						return err
					}
				}
			}

			KeyValue[k157] = v157
		}
		var KeyResult map[int32]int32
		ret, err := _imp.SetIntBatchBS(ModuleName, KeyValue, &KeyResult)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.MAP, 3)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(KeyResult)), 0)
		if err != nil {
			return err
		}
		for k159, v159 := range KeyResult {

			err = _os.Write_int32(k159, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(v159, 1)
			if err != nil {
				return err
			}
		}
	case "setLongBatchBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyValue map[int64][]int8
		err, have = _is.SkipTo(codec.MAP, 2, true)
		if err != nil {
			return err
		}

		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}
		KeyValue = make(map[int64][]int8)
		for i160, e160 := int32(0), length; i160 < e160; i160++ {
			var k160 int64
			var v160 []int8

			err = _is.Read_int64(&k160, 0, false)
			if err != nil {
				return err
			}

			err, have, ty = _is.SkipToNoCheck(1, false)
			if err != nil {
				return err
			}
			if have {
				if ty == codec.LIST {
					err = _is.Read_int32(&length, 0, true)
					if err != nil {
						return err
					}
					v160 = make([]int8, length, length)
					for i161, e161 := int32(0), length; i161 < e161; i161++ {

						err = _is.Read_int8(&v160[i161], 0, false)
						if err != nil {
							return err
						}
					}
				} else if ty == codec.SIMPLE_LIST {

					err, _ = _is.SkipTo(codec.BYTE, 0, true)
					if err != nil {
						return err
					}
					err = _is.Read_int32(&length, 0, true)
					if err != nil {
						return err
					}
					err = _is.Read_slice_int8(&v160, length, true)
					if err != nil {
						return err
					}

				} else {
					err = fmt.Errorf("require vector, but not.")
					if err != nil {
						return err
					}
				}
			}

			KeyValue[k160] = v160
		}
		var KeyResult map[int64]int32
		ret, err := _imp.SetLongBatchBS(ModuleName, KeyValue, &KeyResult)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.MAP, 3)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(KeyResult)), 0)
		if err != nil {
			return err
		}
		for k162, v162 := range KeyResult {

			err = _os.Write_int64(k162, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(v162, 1)
			if err != nil {
				return err
			}
		}
	case "setStringBatchBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyValue []SSetKeyValueBS
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			KeyValue = make([]SSetKeyValueBS, length, length)
			for i163, e163 := int32(0), length; i163 < e163; i163++ {

				err = KeyValue[i163].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var KeyResult []SSetKeyResultBS
		ret, err := _imp.SetStringBatchBS(ModuleName, KeyValue, &KeyResult)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 3)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(KeyResult)), 0)
		if err != nil {
			return err
		}
		for _, v := range KeyResult {

			err = v.WriteBlock(_os, 0)
			if err != nil {
				return err
			}
		}
	case "setStringWithDirty":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem string
		err = _is.Read_string(&KeyItem, 2, true)
		if err != nil {
			return err
		}
		var Value string
		err = _is.Read_string(&Value, 3, true)
		if err != nil {
			return err
		}
		var Dirty bool
		err = _is.Read_bool(&Dirty, 4, true)
		if err != nil {
			return err
		}
		ret, err := _imp.SetStringWithDirty(ModuleName, KeyItem, Value, Dirty)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "setIntWithDirty":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem int32
		err = _is.Read_int32(&KeyItem, 2, true)
		if err != nil {
			return err
		}
		var Value string
		err = _is.Read_string(&Value, 3, true)
		if err != nil {
			return err
		}
		var Dirty bool
		err = _is.Read_bool(&Dirty, 4, true)
		if err != nil {
			return err
		}
		ret, err := _imp.SetIntWithDirty(ModuleName, KeyItem, Value, Dirty)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "setLongWithDirty":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem int64
		err = _is.Read_int64(&KeyItem, 2, true)
		if err != nil {
			return err
		}
		var Value string
		err = _is.Read_string(&Value, 3, true)
		if err != nil {
			return err
		}
		var Dirty bool
		err = _is.Read_bool(&Dirty, 4, true)
		if err != nil {
			return err
		}
		ret, err := _imp.SetLongWithDirty(ModuleName, KeyItem, Value, Dirty)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "setStringWithDirtyBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem []int8
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			KeyItem = make([]int8, length, length)
			for i164, e164 := int32(0), length; i164 < e164; i164++ {

				err = _is.Read_int8(&KeyItem[i164], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&KeyItem, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var Value []int8
		err, have, ty = _is.SkipToNoCheck(3, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			Value = make([]int8, length, length)
			for i165, e165 := int32(0), length; i165 < e165; i165++ {

				err = _is.Read_int8(&Value[i165], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&Value, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var Dirty bool
		err = _is.Read_bool(&Dirty, 4, true)
		if err != nil {
			return err
		}
		ret, err := _imp.SetStringWithDirtyBS(ModuleName, KeyItem, Value, Dirty)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "setIntWithDirtyBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem int32
		err = _is.Read_int32(&KeyItem, 2, true)
		if err != nil {
			return err
		}
		var Value []int8
		err, have, ty = _is.SkipToNoCheck(3, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			Value = make([]int8, length, length)
			for i166, e166 := int32(0), length; i166 < e166; i166++ {

				err = _is.Read_int8(&Value[i166], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&Value, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var Dirty bool
		err = _is.Read_bool(&Dirty, 4, true)
		if err != nil {
			return err
		}
		ret, err := _imp.SetIntWithDirtyBS(ModuleName, KeyItem, Value, Dirty)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "setLongWithDirtyBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem int64
		err = _is.Read_int64(&KeyItem, 2, true)
		if err != nil {
			return err
		}
		var Value []int8
		err, have, ty = _is.SkipToNoCheck(3, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			Value = make([]int8, length, length)
			for i167, e167 := int32(0), length; i167 < e167; i167++ {

				err = _is.Read_int8(&Value[i167], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&Value, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var Dirty bool
		err = _is.Read_bool(&Dirty, 4, true)
		if err != nil {
			return err
		}
		ret, err := _imp.SetLongWithDirtyBS(ModuleName, KeyItem, Value, Dirty)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "setStringEx":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem string
		err = _is.Read_string(&KeyItem, 2, true)
		if err != nil {
			return err
		}
		var Value string
		err = _is.Read_string(&Value, 3, true)
		if err != nil {
			return err
		}
		var Ver int8
		err = _is.Read_int8(&Ver, 4, true)
		if err != nil {
			return err
		}
		var Dirty bool
		err = _is.Read_bool(&Dirty, 5, true)
		if err != nil {
			return err
		}
		var ExpireTimeSecond int32
		err = _is.Read_int32(&ExpireTimeSecond, 6, true)
		if err != nil {
			return err
		}
		ret, err := _imp.SetStringEx(ModuleName, KeyItem, Value, Ver, Dirty, ExpireTimeSecond)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "setIntEx":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem int32
		err = _is.Read_int32(&KeyItem, 2, true)
		if err != nil {
			return err
		}
		var Value string
		err = _is.Read_string(&Value, 3, true)
		if err != nil {
			return err
		}
		var Ver int8
		err = _is.Read_int8(&Ver, 4, true)
		if err != nil {
			return err
		}
		var Dirty bool
		err = _is.Read_bool(&Dirty, 5, true)
		if err != nil {
			return err
		}
		var ExpireTimeSecond int32
		err = _is.Read_int32(&ExpireTimeSecond, 6, true)
		if err != nil {
			return err
		}
		ret, err := _imp.SetIntEx(ModuleName, KeyItem, Value, Ver, Dirty, ExpireTimeSecond)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "setLongEx":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem int64
		err = _is.Read_int64(&KeyItem, 2, true)
		if err != nil {
			return err
		}
		var Value string
		err = _is.Read_string(&Value, 3, true)
		if err != nil {
			return err
		}
		var Ver int8
		err = _is.Read_int8(&Ver, 4, true)
		if err != nil {
			return err
		}
		var Dirty bool
		err = _is.Read_bool(&Dirty, 5, true)
		if err != nil {
			return err
		}
		var ExpireTimeSecond int32
		err = _is.Read_int32(&ExpireTimeSecond, 6, true)
		if err != nil {
			return err
		}
		ret, err := _imp.SetLongEx(ModuleName, KeyItem, Value, Ver, Dirty, ExpireTimeSecond)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "setStringExBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem []int8
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			KeyItem = make([]int8, length, length)
			for i168, e168 := int32(0), length; i168 < e168; i168++ {

				err = _is.Read_int8(&KeyItem[i168], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&KeyItem, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var Value []int8
		err, have, ty = _is.SkipToNoCheck(3, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			Value = make([]int8, length, length)
			for i169, e169 := int32(0), length; i169 < e169; i169++ {

				err = _is.Read_int8(&Value[i169], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&Value, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var Ver int8
		err = _is.Read_int8(&Ver, 4, true)
		if err != nil {
			return err
		}
		var Dirty bool
		err = _is.Read_bool(&Dirty, 5, true)
		if err != nil {
			return err
		}
		var ExpireTimeSecond int32
		err = _is.Read_int32(&ExpireTimeSecond, 6, true)
		if err != nil {
			return err
		}
		ret, err := _imp.SetStringExBS(ModuleName, KeyItem, Value, Ver, Dirty, ExpireTimeSecond)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "setIntExBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem int32
		err = _is.Read_int32(&KeyItem, 2, true)
		if err != nil {
			return err
		}
		var Value []int8
		err, have, ty = _is.SkipToNoCheck(3, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			Value = make([]int8, length, length)
			for i170, e170 := int32(0), length; i170 < e170; i170++ {

				err = _is.Read_int8(&Value[i170], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&Value, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var Ver int8
		err = _is.Read_int8(&Ver, 4, true)
		if err != nil {
			return err
		}
		var Dirty bool
		err = _is.Read_bool(&Dirty, 5, true)
		if err != nil {
			return err
		}
		var ExpireTimeSecond int32
		err = _is.Read_int32(&ExpireTimeSecond, 6, true)
		if err != nil {
			return err
		}
		ret, err := _imp.SetIntExBS(ModuleName, KeyItem, Value, Ver, Dirty, ExpireTimeSecond)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "setLongExBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem int64
		err = _is.Read_int64(&KeyItem, 2, true)
		if err != nil {
			return err
		}
		var Value []int8
		err, have, ty = _is.SkipToNoCheck(3, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			Value = make([]int8, length, length)
			for i171, e171 := int32(0), length; i171 < e171; i171++ {

				err = _is.Read_int8(&Value[i171], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&Value, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var Ver int8
		err = _is.Read_int8(&Ver, 4, true)
		if err != nil {
			return err
		}
		var Dirty bool
		err = _is.Read_bool(&Dirty, 5, true)
		if err != nil {
			return err
		}
		var ExpireTimeSecond int32
		err = _is.Read_int32(&ExpireTimeSecond, 6, true)
		if err != nil {
			return err
		}
		ret, err := _imp.SetLongExBS(ModuleName, KeyItem, Value, Ver, Dirty, ExpireTimeSecond)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "setStringExBatch":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyValue []SSetKeyValue
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			KeyValue = make([]SSetKeyValue, length, length)
			for i172, e172 := int32(0), length; i172 < e172; i172++ {

				err = KeyValue[i172].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var KeyResult map[string]int32
		ret, err := _imp.SetStringExBatch(ModuleName, KeyValue, &KeyResult)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.MAP, 3)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(KeyResult)), 0)
		if err != nil {
			return err
		}
		for k173, v173 := range KeyResult {

			err = _os.Write_string(k173, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(v173, 1)
			if err != nil {
				return err
			}
		}
	case "setIntExBatch":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyValue []ISetKeyValue
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			KeyValue = make([]ISetKeyValue, length, length)
			for i174, e174 := int32(0), length; i174 < e174; i174++ {

				err = KeyValue[i174].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var KeyResult map[int32]int32
		ret, err := _imp.SetIntExBatch(ModuleName, KeyValue, &KeyResult)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.MAP, 3)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(KeyResult)), 0)
		if err != nil {
			return err
		}
		for k175, v175 := range KeyResult {

			err = _os.Write_int32(k175, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(v175, 1)
			if err != nil {
				return err
			}
		}
	case "setLongExBatch":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyValue []LSetKeyValue
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			KeyValue = make([]LSetKeyValue, length, length)
			for i176, e176 := int32(0), length; i176 < e176; i176++ {

				err = KeyValue[i176].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var KeyResult map[int64]int32
		ret, err := _imp.SetLongExBatch(ModuleName, KeyValue, &KeyResult)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.MAP, 3)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(KeyResult)), 0)
		if err != nil {
			return err
		}
		for k177, v177 := range KeyResult {

			err = _os.Write_int64(k177, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(v177, 1)
			if err != nil {
				return err
			}
		}
	case "setStringExBatchBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyValue []SSetKeyValueBS
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			KeyValue = make([]SSetKeyValueBS, length, length)
			for i178, e178 := int32(0), length; i178 < e178; i178++ {

				err = KeyValue[i178].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var KeyResult []SSetKeyResultBS
		ret, err := _imp.SetStringExBatchBS(ModuleName, KeyValue, &KeyResult)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 3)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(KeyResult)), 0)
		if err != nil {
			return err
		}
		for _, v := range KeyResult {

			err = v.WriteBlock(_os, 0)
			if err != nil {
				return err
			}
		}
	case "setIntExBatchBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyValue []ISetKeyValueBS
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			KeyValue = make([]ISetKeyValueBS, length, length)
			for i179, e179 := int32(0), length; i179 < e179; i179++ {

				err = KeyValue[i179].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var KeyResult map[int32]int32
		ret, err := _imp.SetIntExBatchBS(ModuleName, KeyValue, &KeyResult)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.MAP, 3)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(KeyResult)), 0)
		if err != nil {
			return err
		}
		for k180, v180 := range KeyResult {

			err = _os.Write_int32(k180, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(v180, 1)
			if err != nil {
				return err
			}
		}
	case "setLongExBatchBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyValue []LSetKeyValueBS
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			KeyValue = make([]LSetKeyValueBS, length, length)
			for i181, e181 := int32(0), length; i181 < e181; i181++ {

				err = KeyValue[i181].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var KeyResult map[int64]int32
		ret, err := _imp.SetLongExBatchBS(ModuleName, KeyValue, &KeyResult)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.MAP, 3)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(KeyResult)), 0)
		if err != nil {
			return err
		}
		for k182, v182 := range KeyResult {

			err = _os.Write_int64(k182, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(v182, 1)
			if err != nil {
				return err
			}
		}
	case "updateIntEx":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem int32
		err = _is.Read_int32(&KeyItem, 2, true)
		if err != nil {
			return err
		}
		var Value string
		err = _is.Read_string(&Value, 3, true)
		if err != nil {
			return err
		}
		var Dirty bool
		err = _is.Read_bool(&Dirty, 4, true)
		if err != nil {
			return err
		}
		var ExpireTimeSecond int32
		err = _is.Read_int32(&ExpireTimeSecond, 5, true)
		if err != nil {
			return err
		}
		var Option Op
		err = _is.Read_int32((*int32)(&Option), 6, true)
		if err != nil {
			return err
		}
		var RetValue string
		ret, err := _imp.UpdateIntEx(ModuleName, KeyItem, Value, Dirty, ExpireTimeSecond, Option, &RetValue)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.Write_string(RetValue, 7)
		if err != nil {
			return err
		}
	case "updateIntExBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem int32
		err = _is.Read_int32(&KeyItem, 2, true)
		if err != nil {
			return err
		}
		var Value []int8
		err, have, ty = _is.SkipToNoCheck(3, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			Value = make([]int8, length, length)
			for i183, e183 := int32(0), length; i183 < e183; i183++ {

				err = _is.Read_int8(&Value[i183], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&Value, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var Dirty bool
		err = _is.Read_bool(&Dirty, 4, true)
		if err != nil {
			return err
		}
		var ExpireTimeSecond int32
		err = _is.Read_int32(&ExpireTimeSecond, 5, true)
		if err != nil {
			return err
		}
		var Option Op
		err = _is.Read_int32((*int32)(&Option), 6, true)
		if err != nil {
			return err
		}
		var RetValue []int8
		ret, err := _imp.UpdateIntExBS(ModuleName, KeyItem, Value, Dirty, ExpireTimeSecond, Option, &RetValue)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.SIMPLE_LIST, 7)
		if err != nil {
			return err
		}
		err = _os.WriteHead(codec.BYTE, 0)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(RetValue)), 0)
		if err != nil {
			return err
		}
		err = _os.Write_slice_int8(RetValue)
		if err != nil {
			return err
		}
	case "updateLongEx":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem int64
		err = _is.Read_int64(&KeyItem, 2, true)
		if err != nil {
			return err
		}
		var Value string
		err = _is.Read_string(&Value, 3, true)
		if err != nil {
			return err
		}
		var Dirty bool
		err = _is.Read_bool(&Dirty, 4, true)
		if err != nil {
			return err
		}
		var ExpireTimeSecond int32
		err = _is.Read_int32(&ExpireTimeSecond, 5, true)
		if err != nil {
			return err
		}
		var Option Op
		err = _is.Read_int32((*int32)(&Option), 6, true)
		if err != nil {
			return err
		}
		var RetValue string
		ret, err := _imp.UpdateLongEx(ModuleName, KeyItem, Value, Dirty, ExpireTimeSecond, Option, &RetValue)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.Write_string(RetValue, 7)
		if err != nil {
			return err
		}
	case "updateLongExBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem int64
		err = _is.Read_int64(&KeyItem, 2, true)
		if err != nil {
			return err
		}
		var Value []int8
		err, have, ty = _is.SkipToNoCheck(3, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			Value = make([]int8, length, length)
			for i184, e184 := int32(0), length; i184 < e184; i184++ {

				err = _is.Read_int8(&Value[i184], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&Value, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var Dirty bool
		err = _is.Read_bool(&Dirty, 4, true)
		if err != nil {
			return err
		}
		var ExpireTimeSecond int32
		err = _is.Read_int32(&ExpireTimeSecond, 5, true)
		if err != nil {
			return err
		}
		var Option Op
		err = _is.Read_int32((*int32)(&Option), 6, true)
		if err != nil {
			return err
		}
		var RetValue []int8
		ret, err := _imp.UpdateLongExBS(ModuleName, KeyItem, Value, Dirty, ExpireTimeSecond, Option, &RetValue)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.SIMPLE_LIST, 7)
		if err != nil {
			return err
		}
		err = _os.WriteHead(codec.BYTE, 0)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(RetValue)), 0)
		if err != nil {
			return err
		}
		err = _os.Write_slice_int8(RetValue)
		if err != nil {
			return err
		}
	case "updateStringEx":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem string
		err = _is.Read_string(&KeyItem, 2, true)
		if err != nil {
			return err
		}
		var Value string
		err = _is.Read_string(&Value, 3, true)
		if err != nil {
			return err
		}
		var Dirty bool
		err = _is.Read_bool(&Dirty, 4, true)
		if err != nil {
			return err
		}
		var ExpireTimeSecond int32
		err = _is.Read_int32(&ExpireTimeSecond, 5, true)
		if err != nil {
			return err
		}
		var Option Op
		err = _is.Read_int32((*int32)(&Option), 6, true)
		if err != nil {
			return err
		}
		var RetValue string
		ret, err := _imp.UpdateStringEx(ModuleName, KeyItem, Value, Dirty, ExpireTimeSecond, Option, &RetValue)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.Write_string(RetValue, 7)
		if err != nil {
			return err
		}
	case "updateStringExBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem []int8
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			KeyItem = make([]int8, length, length)
			for i185, e185 := int32(0), length; i185 < e185; i185++ {

				err = _is.Read_int8(&KeyItem[i185], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&KeyItem, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var Value []int8
		err, have, ty = _is.SkipToNoCheck(3, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			Value = make([]int8, length, length)
			for i186, e186 := int32(0), length; i186 < e186; i186++ {

				err = _is.Read_int8(&Value[i186], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&Value, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var Dirty bool
		err = _is.Read_bool(&Dirty, 4, true)
		if err != nil {
			return err
		}
		var ExpireTimeSecond int32
		err = _is.Read_int32(&ExpireTimeSecond, 5, true)
		if err != nil {
			return err
		}
		var Option Op
		err = _is.Read_int32((*int32)(&Option), 6, true)
		if err != nil {
			return err
		}
		var RetValue []int8
		ret, err := _imp.UpdateStringExBS(ModuleName, KeyItem, Value, Dirty, ExpireTimeSecond, Option, &RetValue)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.SIMPLE_LIST, 7)
		if err != nil {
			return err
		}
		err = _os.WriteHead(codec.BYTE, 0)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(RetValue)), 0)
		if err != nil {
			return err
		}
		err = _os.Write_slice_int8(RetValue)
		if err != nil {
			return err
		}
	case "eraseString":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem string
		err = _is.Read_string(&KeyItem, 2, true)
		if err != nil {
			return err
		}
		ret, err := _imp.EraseString(ModuleName, KeyItem)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "eraseInt":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem int32
		err = _is.Read_int32(&KeyItem, 2, true)
		if err != nil {
			return err
		}
		ret, err := _imp.EraseInt(ModuleName, KeyItem)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "eraseLong":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem int64
		err = _is.Read_int64(&KeyItem, 2, true)
		if err != nil {
			return err
		}
		ret, err := _imp.EraseLong(ModuleName, KeyItem)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "eraseStringBatch":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem map[string]int8
		err, have = _is.SkipTo(codec.MAP, 2, true)
		if err != nil {
			return err
		}

		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}
		KeyItem = make(map[string]int8)
		for i187, e187 := int32(0), length; i187 < e187; i187++ {
			var k187 string
			var v187 int8

			err = _is.Read_string(&k187, 0, false)
			if err != nil {
				return err
			}

			err = _is.Read_int8(&v187, 1, false)
			if err != nil {
				return err
			}

			KeyItem[k187] = v187
		}
		var KeyResult map[string]int32
		ret, err := _imp.EraseStringBatch(ModuleName, KeyItem, &KeyResult)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.MAP, 3)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(KeyResult)), 0)
		if err != nil {
			return err
		}
		for k188, v188 := range KeyResult {

			err = _os.Write_string(k188, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(v188, 1)
			if err != nil {
				return err
			}
		}
	case "eraseIntBatch":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem map[int32]int8
		err, have = _is.SkipTo(codec.MAP, 2, true)
		if err != nil {
			return err
		}

		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}
		KeyItem = make(map[int32]int8)
		for i189, e189 := int32(0), length; i189 < e189; i189++ {
			var k189 int32
			var v189 int8

			err = _is.Read_int32(&k189, 0, false)
			if err != nil {
				return err
			}

			err = _is.Read_int8(&v189, 1, false)
			if err != nil {
				return err
			}

			KeyItem[k189] = v189
		}
		var KeyResult map[int32]int32
		ret, err := _imp.EraseIntBatch(ModuleName, KeyItem, &KeyResult)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.MAP, 3)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(KeyResult)), 0)
		if err != nil {
			return err
		}
		for k190, v190 := range KeyResult {

			err = _os.Write_int32(k190, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(v190, 1)
			if err != nil {
				return err
			}
		}
	case "eraseLongBatch":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem map[int64]int8
		err, have = _is.SkipTo(codec.MAP, 2, true)
		if err != nil {
			return err
		}

		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}
		KeyItem = make(map[int64]int8)
		for i191, e191 := int32(0), length; i191 < e191; i191++ {
			var k191 int64
			var v191 int8

			err = _is.Read_int64(&k191, 0, false)
			if err != nil {
				return err
			}

			err = _is.Read_int8(&v191, 1, false)
			if err != nil {
				return err
			}

			KeyItem[k191] = v191
		}
		var KeyResult map[int64]int32
		ret, err := _imp.EraseLongBatch(ModuleName, KeyItem, &KeyResult)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.MAP, 3)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(KeyResult)), 0)
		if err != nil {
			return err
		}
		for k192, v192 := range KeyResult {

			err = _os.Write_int64(k192, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(v192, 1)
			if err != nil {
				return err
			}
		}
	case "eraseStringBatchBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem []SKeyVersionBS
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			KeyItem = make([]SKeyVersionBS, length, length)
			for i193, e193 := int32(0), length; i193 < e193; i193++ {

				err = KeyItem[i193].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var KeyResult []SKeyResultBS
		ret, err := _imp.EraseStringBatchBS(ModuleName, KeyItem, &KeyResult)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 3)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(KeyResult)), 0)
		if err != nil {
			return err
		}
		for _, v := range KeyResult {

			err = v.WriteBlock(_os, 0)
			if err != nil {
				return err
			}
		}
	case "eraseStringBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem []int8
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			KeyItem = make([]int8, length, length)
			for i194, e194 := int32(0), length; i194 < e194; i194++ {

				err = _is.Read_int8(&KeyItem[i194], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&KeyItem, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		ret, err := _imp.EraseStringBS(ModuleName, KeyItem)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "delString":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem string
		err = _is.Read_string(&KeyItem, 2, true)
		if err != nil {
			return err
		}
		ret, err := _imp.DelString(ModuleName, KeyItem)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "delInt":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem int32
		err = _is.Read_int32(&KeyItem, 2, true)
		if err != nil {
			return err
		}
		ret, err := _imp.DelInt(ModuleName, KeyItem)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "delLong":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem int64
		err = _is.Read_int64(&KeyItem, 2, true)
		if err != nil {
			return err
		}
		ret, err := _imp.DelLong(ModuleName, KeyItem)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "delStringBatch":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem map[string]int8
		err, have = _is.SkipTo(codec.MAP, 2, true)
		if err != nil {
			return err
		}

		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}
		KeyItem = make(map[string]int8)
		for i195, e195 := int32(0), length; i195 < e195; i195++ {
			var k195 string
			var v195 int8

			err = _is.Read_string(&k195, 0, false)
			if err != nil {
				return err
			}

			err = _is.Read_int8(&v195, 1, false)
			if err != nil {
				return err
			}

			KeyItem[k195] = v195
		}
		var KeyResult map[string]int32
		ret, err := _imp.DelStringBatch(ModuleName, KeyItem, &KeyResult)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.MAP, 3)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(KeyResult)), 0)
		if err != nil {
			return err
		}
		for k196, v196 := range KeyResult {

			err = _os.Write_string(k196, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(v196, 1)
			if err != nil {
				return err
			}
		}
	case "delIntBatch":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem map[int32]int8
		err, have = _is.SkipTo(codec.MAP, 2, true)
		if err != nil {
			return err
		}

		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}
		KeyItem = make(map[int32]int8)
		for i197, e197 := int32(0), length; i197 < e197; i197++ {
			var k197 int32
			var v197 int8

			err = _is.Read_int32(&k197, 0, false)
			if err != nil {
				return err
			}

			err = _is.Read_int8(&v197, 1, false)
			if err != nil {
				return err
			}

			KeyItem[k197] = v197
		}
		var KeyResult map[int32]int32
		ret, err := _imp.DelIntBatch(ModuleName, KeyItem, &KeyResult)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.MAP, 3)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(KeyResult)), 0)
		if err != nil {
			return err
		}
		for k198, v198 := range KeyResult {

			err = _os.Write_int32(k198, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(v198, 1)
			if err != nil {
				return err
			}
		}
	case "delLongBatch":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem map[int64]int8
		err, have = _is.SkipTo(codec.MAP, 2, true)
		if err != nil {
			return err
		}

		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}
		KeyItem = make(map[int64]int8)
		for i199, e199 := int32(0), length; i199 < e199; i199++ {
			var k199 int64
			var v199 int8

			err = _is.Read_int64(&k199, 0, false)
			if err != nil {
				return err
			}

			err = _is.Read_int8(&v199, 1, false)
			if err != nil {
				return err
			}

			KeyItem[k199] = v199
		}
		var KeyResult map[int64]int32
		ret, err := _imp.DelLongBatch(ModuleName, KeyItem, &KeyResult)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.MAP, 3)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(KeyResult)), 0)
		if err != nil {
			return err
		}
		for k200, v200 := range KeyResult {

			err = _os.Write_int64(k200, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(v200, 1)
			if err != nil {
				return err
			}
		}
	case "delStringBatchBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem []SKeyVersionBS
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			KeyItem = make([]SKeyVersionBS, length, length)
			for i201, e201 := int32(0), length; i201 < e201; i201++ {

				err = KeyItem[i201].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var KeyResult []SKeyResultBS
		ret, err := _imp.DelStringBatchBS(ModuleName, KeyItem, &KeyResult)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 3)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(KeyResult)), 0)
		if err != nil {
			return err
		}
		for _, v := range KeyResult {

			err = v.WriteBlock(_os, 0)
			if err != nil {
				return err
			}
		}
	case "delStringBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var KeyItem []int8
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			KeyItem = make([]int8, length, length)
			for i202, e202 := int32(0), length; i202 < e202; i202++ {

				err = _is.Read_int8(&KeyItem[i202], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&KeyItem, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		ret, err := _imp.DelStringBS(ModuleName, KeyItem)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "getAllMainKey":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var Index int32
		err = _is.Read_int32(&Index, 2, true)
		if err != nil {
			return err
		}
		var Count int32
		err = _is.Read_int32(&Count, 3, true)
		if err != nil {
			return err
		}
		var MainKey []string
		var IsEnd bool
		ret, err := _imp.GetAllMainKey(ModuleName, Index, Count, &MainKey, &IsEnd)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 4)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(MainKey)), 0)
		if err != nil {
			return err
		}
		for _, v := range MainKey {

			err = _os.Write_string(v, 0)
			if err != nil {
				return err
			}
		}

		err = _os.Write_bool(IsEnd, 5)
		if err != nil {
			return err
		}
	case "select":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainIndex string
		err = _is.Read_string(&MainIndex, 2, true)
		if err != nil {
			return err
		}
		var Field string
		err = _is.Read_string(&Field, 3, true)
		if err != nil {
			return err
		}
		var VtCond []Condition
		err, have, ty = _is.SkipToNoCheck(4, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtCond = make([]Condition, length, length)
			for i203, e203 := int32(0), length; i203 < e203; i203++ {

				err = VtCond[i203].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var VtData []map[string]string
		ret, err := _imp.Select(ModuleName, MainIndex, Field, VtCond, &VtData)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 5)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(VtData)), 0)
		if err != nil {
			return err
		}
		for _, v := range VtData {

			err = _os.WriteHead(codec.MAP, 0)
			if err != nil {
				return err
			}
			err = _os.Write_int32(int32(len(v)), 0)
			if err != nil {
				return err
			}
			for k204, v204 := range v {

				err = _os.Write_string(k204, 0)
				if err != nil {
					return err
				}

				err = _os.Write_string(v204, 1)
				if err != nil {
					return err
				}
			}
		}
	case "selectBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainIndex []int8
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			MainIndex = make([]int8, length, length)
			for i205, e205 := int32(0), length; i205 < e205; i205++ {

				err = _is.Read_int8(&MainIndex[i205], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&MainIndex, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var Field string
		err = _is.Read_string(&Field, 3, true)
		if err != nil {
			return err
		}
		var VtCond []ConditionBS
		err, have, ty = _is.SkipToNoCheck(4, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtCond = make([]ConditionBS, length, length)
			for i206, e206 := int32(0), length; i206 < e206; i206++ {

				err = VtCond[i206].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var VtData []map[string][]int8
		ret, err := _imp.SelectBS(ModuleName, MainIndex, Field, VtCond, &VtData)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 5)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(VtData)), 0)
		if err != nil {
			return err
		}
		for _, v := range VtData {

			err = _os.WriteHead(codec.MAP, 0)
			if err != nil {
				return err
			}
			err = _os.Write_int32(int32(len(v)), 0)
			if err != nil {
				return err
			}
			for k207, v207 := range v {

				err = _os.Write_string(k207, 0)
				if err != nil {
					return err
				}

				err = _os.WriteHead(codec.SIMPLE_LIST, 1)
				if err != nil {
					return err
				}
				err = _os.WriteHead(codec.BYTE, 0)
				if err != nil {
					return err
				}
				err = _os.Write_int32(int32(len(v207)), 0)
				if err != nil {
					return err
				}
				err = _os.Write_slice_int8(v207)
				if err != nil {
					return err
				}
			}
		}
	case "selectEx":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainIndex string
		err = _is.Read_string(&MainIndex, 2, true)
		if err != nil {
			return err
		}
		var Field string
		err = _is.Read_string(&Field, 3, true)
		if err != nil {
			return err
		}
		var VtCond []Condition
		err, have, ty = _is.SkipToNoCheck(4, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtCond = make([]Condition, length, length)
			for i208, e208 := int32(0), length; i208 < e208; i208++ {

				err = VtCond[i208].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var BGetMKCout bool
		err = _is.Read_bool(&BGetMKCout, 5, true)
		if err != nil {
			return err
		}
		var VtData []map[string]string
		ret, err := _imp.SelectEx(ModuleName, MainIndex, Field, VtCond, BGetMKCout, &VtData)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 6)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(VtData)), 0)
		if err != nil {
			return err
		}
		for _, v := range VtData {

			err = _os.WriteHead(codec.MAP, 0)
			if err != nil {
				return err
			}
			err = _os.Write_int32(int32(len(v)), 0)
			if err != nil {
				return err
			}
			for k209, v209 := range v {

				err = _os.Write_string(k209, 0)
				if err != nil {
					return err
				}

				err = _os.Write_string(v209, 1)
				if err != nil {
					return err
				}
			}
		}
	case "selectBSEx":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainIndex []int8
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			MainIndex = make([]int8, length, length)
			for i210, e210 := int32(0), length; i210 < e210; i210++ {

				err = _is.Read_int8(&MainIndex[i210], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&MainIndex, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var Field string
		err = _is.Read_string(&Field, 3, true)
		if err != nil {
			return err
		}
		var VtCond []ConditionBS
		err, have, ty = _is.SkipToNoCheck(4, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtCond = make([]ConditionBS, length, length)
			for i211, e211 := int32(0), length; i211 < e211; i211++ {

				err = VtCond[i211].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var BGetMKCout bool
		err = _is.Read_bool(&BGetMKCout, 5, true)
		if err != nil {
			return err
		}
		var VtData []map[string][]int8
		ret, err := _imp.SelectBSEx(ModuleName, MainIndex, Field, VtCond, BGetMKCout, &VtData)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 6)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(VtData)), 0)
		if err != nil {
			return err
		}
		for _, v := range VtData {

			err = _os.WriteHead(codec.MAP, 0)
			if err != nil {
				return err
			}
			err = _os.Write_int32(int32(len(v)), 0)
			if err != nil {
				return err
			}
			for k212, v212 := range v {

				err = _os.Write_string(k212, 0)
				if err != nil {
					return err
				}

				err = _os.WriteHead(codec.SIMPLE_LIST, 1)
				if err != nil {
					return err
				}
				err = _os.WriteHead(codec.BYTE, 0)
				if err != nil {
					return err
				}
				err = _os.Write_int32(int32(len(v212)), 0)
				if err != nil {
					return err
				}
				err = _os.Write_slice_int8(v212)
				if err != nil {
					return err
				}
			}
		}
	case "selectBin":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainKey string
		err = _is.Read_string(&MainKey, 2, true)
		if err != nil {
			return err
		}
		var VtCond []Condition
		err, have, ty = _is.SkipToNoCheck(3, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtCond = make([]Condition, length, length)
			for i213, e213 := int32(0), length; i213 < e213; i213++ {

				err = VtCond[i213].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var BGetMKCout bool
		err = _is.Read_bool(&BGetMKCout, 4, true)
		if err != nil {
			return err
		}
		var VtData []int8
		ret, err := _imp.SelectBin(ModuleName, MainKey, VtCond, BGetMKCout, &VtData)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.SIMPLE_LIST, 5)
		if err != nil {
			return err
		}
		err = _os.WriteHead(codec.BYTE, 0)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(VtData)), 0)
		if err != nil {
			return err
		}
		err = _os.Write_slice_int8(VtData)
		if err != nil {
			return err
		}
	case "selectByPos":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainIndex string
		err = _is.Read_string(&MainIndex, 2, true)
		if err != nil {
			return err
		}
		var Field string
		err = _is.Read_string(&Field, 3, true)
		if err != nil {
			return err
		}
		var VtCond []Condition
		err, have, ty = _is.SkipToNoCheck(4, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtCond = make([]Condition, length, length)
			for i214, e214 := int32(0), length; i214 < e214; i214++ {

				err = VtCond[i214].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var ICount uint32
		err = _is.Read_uint32(&ICount, 5, true)
		if err != nil {
			return err
		}
		var DirectionType DirectionType
		err = _is.Read_int32((*int32)(&DirectionType), 6, true)
		if err != nil {
			return err
		}
		var VtData []map[string]string
		ret, err := _imp.SelectByPos(ModuleName, MainIndex, Field, VtCond, ICount, DirectionType, &VtData)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 7)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(VtData)), 0)
		if err != nil {
			return err
		}
		for _, v := range VtData {

			err = _os.WriteHead(codec.MAP, 0)
			if err != nil {
				return err
			}
			err = _os.Write_int32(int32(len(v)), 0)
			if err != nil {
				return err
			}
			for k215, v215 := range v {

				err = _os.Write_string(k215, 0)
				if err != nil {
					return err
				}

				err = _os.Write_string(v215, 1)
				if err != nil {
					return err
				}
			}
		}
	case "selectBatch":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var VtMainKey []string
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtMainKey = make([]string, length, length)
			for i216, e216 := int32(0), length; i216 < e216; i216++ {

				err = _is.Read_string(&VtMainKey[i216], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var Field string
		err = _is.Read_string(&Field, 3, true)
		if err != nil {
			return err
		}
		var VtCond []Condition
		err, have, ty = _is.SkipToNoCheck(4, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtCond = make([]Condition, length, length)
			for i217, e217 := int32(0), length; i217 < e217; i217++ {

				err = VtCond[i217].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var VtData []MainKeyValue
		ret, err := _imp.SelectBatch(ModuleName, VtMainKey, Field, VtCond, &VtData)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 5)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(VtData)), 0)
		if err != nil {
			return err
		}
		for _, v := range VtData {

			err = v.WriteBlock(_os, 0)
			if err != nil {
				return err
			}
		}
	case "selectBatchBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var VtMainKey [][]int8
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtMainKey = make([][]int8, length, length)
			for i218, e218 := int32(0), length; i218 < e218; i218++ {

				err, have, ty = _is.SkipToNoCheck(0, false)
				if err != nil {
					return err
				}
				if have {
					if ty == codec.LIST {
						err = _is.Read_int32(&length, 0, true)
						if err != nil {
							return err
						}
						VtMainKey[i218] = make([]int8, length, length)
						for i219, e219 := int32(0), length; i219 < e219; i219++ {

							err = _is.Read_int8(&VtMainKey[i218][i219], 0, false)
							if err != nil {
								return err
							}
						}
					} else if ty == codec.SIMPLE_LIST {

						err, _ = _is.SkipTo(codec.BYTE, 0, true)
						if err != nil {
							return err
						}
						err = _is.Read_int32(&length, 0, true)
						if err != nil {
							return err
						}
						err = _is.Read_slice_int8(&VtMainKey[i218], length, true)
						if err != nil {
							return err
						}

					} else {
						err = fmt.Errorf("require vector, but not.")
						if err != nil {
							return err
						}
					}
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var Field string
		err = _is.Read_string(&Field, 3, true)
		if err != nil {
			return err
		}
		var VtCond []ConditionBS
		err, have, ty = _is.SkipToNoCheck(4, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtCond = make([]ConditionBS, length, length)
			for i220, e220 := int32(0), length; i220 < e220; i220++ {

				err = VtCond[i220].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var VtData []MainKeyValueBS
		ret, err := _imp.SelectBatchBS(ModuleName, VtMainKey, Field, VtCond, &VtData)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 5)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(VtData)), 0)
		if err != nil {
			return err
		}
		for _, v := range VtData {

			err = v.WriteBlock(_os, 0)
			if err != nil {
				return err
			}
		}
	case "selectBinBatch":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var VtMainKey []string
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtMainKey = make([]string, length, length)
			for i221, e221 := int32(0), length; i221 < e221; i221++ {

				err = _is.Read_string(&VtMainKey[i221], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var VtCond []Condition
		err, have, ty = _is.SkipToNoCheck(3, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtCond = make([]Condition, length, length)
			for i222, e222 := int32(0), length; i222 < e222; i222++ {

				err = VtCond[i222].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var VtData []MainKeyValueBin
		ret, err := _imp.SelectBinBatch(ModuleName, VtMainKey, VtCond, &VtData)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 4)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(VtData)), 0)
		if err != nil {
			return err
		}
		for _, v := range VtData {

			err = v.WriteBlock(_os, 0)
			if err != nil {
				return err
			}
		}
	case "selectBatchEx":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var VtMUKey []Record
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtMUKey = make([]Record, length, length)
			for i223, e223 := int32(0), length; i223 < e223; i223++ {

				err = VtMUKey[i223].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var Field string
		err = _is.Read_string(&Field, 3, true)
		if err != nil {
			return err
		}
		var VtData []Record
		ret, err := _imp.SelectBatchEx(ModuleName, VtMUKey, Field, &VtData)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 4)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(VtData)), 0)
		if err != nil {
			return err
		}
		for _, v := range VtData {

			err = v.WriteBlock(_os, 0)
			if err != nil {
				return err
			}
		}
	case "selectBatchExBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var VtMUKey []RecordBS
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtMUKey = make([]RecordBS, length, length)
			for i224, e224 := int32(0), length; i224 < e224; i224++ {

				err = VtMUKey[i224].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var Field string
		err = _is.Read_string(&Field, 3, true)
		if err != nil {
			return err
		}
		var VtData []RecordBS
		ret, err := _imp.SelectBatchExBS(ModuleName, VtMUKey, Field, &VtData)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 4)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(VtData)), 0)
		if err != nil {
			return err
		}
		for _, v := range VtData {

			err = v.WriteBlock(_os, 0)
			if err != nil {
				return err
			}
		}
	case "selectBatchOr":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var VtKey []MainKeyCondition
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtKey = make([]MainKeyCondition, length, length)
			for i225, e225 := int32(0), length; i225 < e225; i225++ {

				err = VtKey[i225].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var VtData []MainKeyValue
		ret, err := _imp.SelectBatchOr(ModuleName, VtKey, &VtData)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 3)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(VtData)), 0)
		if err != nil {
			return err
		}
		for _, v := range VtData {

			err = v.WriteBlock(_os, 0)
			if err != nil {
				return err
			}
		}
	case "selectBatchOrBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var VtKey []MainKeyConditionBS
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtKey = make([]MainKeyConditionBS, length, length)
			for i226, e226 := int32(0), length; i226 < e226; i226++ {

				err = VtKey[i226].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var VtData []MainKeyValueBS
		ret, err := _imp.SelectBatchOrBS(ModuleName, VtKey, &VtData)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 3)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(VtData)), 0)
		if err != nil {
			return err
		}
		for _, v := range VtData {

			err = v.WriteBlock(_os, 0)
			if err != nil {
				return err
			}
		}
	case "insert":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainIndex string
		err = _is.Read_string(&MainIndex, 2, true)
		if err != nil {
			return err
		}
		var MpValue map[string]UpdateValue
		err, have = _is.SkipTo(codec.MAP, 3, true)
		if err != nil {
			return err
		}

		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}
		MpValue = make(map[string]UpdateValue)
		for i227, e227 := int32(0), length; i227 < e227; i227++ {
			var k227 string
			var v227 UpdateValue

			err = _is.Read_string(&k227, 0, false)
			if err != nil {
				return err
			}

			err = v227.ReadBlock(_is, 1, false)
			if err != nil {
				return err
			}

			MpValue[k227] = v227
		}
		var Replace bool
		err = _is.Read_bool(&Replace, 4, true)
		if err != nil {
			return err
		}
		ret, err := _imp.Insert(ModuleName, MainIndex, MpValue, Replace)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "insertBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainIndex []int8
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			MainIndex = make([]int8, length, length)
			for i228, e228 := int32(0), length; i228 < e228; i228++ {

				err = _is.Read_int8(&MainIndex[i228], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&MainIndex, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var MpValue map[string]UpdateValueBS
		err, have = _is.SkipTo(codec.MAP, 3, true)
		if err != nil {
			return err
		}

		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}
		MpValue = make(map[string]UpdateValueBS)
		for i229, e229 := int32(0), length; i229 < e229; i229++ {
			var k229 string
			var v229 UpdateValueBS

			err = _is.Read_string(&k229, 0, false)
			if err != nil {
				return err
			}

			err = v229.ReadBlock(_is, 1, false)
			if err != nil {
				return err
			}

			MpValue[k229] = v229
		}
		var Replace bool
		err = _is.Read_bool(&Replace, 4, true)
		if err != nil {
			return err
		}
		ret, err := _imp.InsertBS(ModuleName, MainIndex, MpValue, Replace)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "insertEx":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainIndex string
		err = _is.Read_string(&MainIndex, 2, true)
		if err != nil {
			return err
		}
		var MpValue map[string]UpdateValue
		err, have = _is.SkipTo(codec.MAP, 3, true)
		if err != nil {
			return err
		}

		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}
		MpValue = make(map[string]UpdateValue)
		for i230, e230 := int32(0), length; i230 < e230; i230++ {
			var k230 string
			var v230 UpdateValue

			err = _is.Read_string(&k230, 0, false)
			if err != nil {
				return err
			}

			err = v230.ReadBlock(_is, 1, false)
			if err != nil {
				return err
			}

			MpValue[k230] = v230
		}
		var Ver int8
		err = _is.Read_int8(&Ver, 4, true)
		if err != nil {
			return err
		}
		var Dirty bool
		err = _is.Read_bool(&Dirty, 5, true)
		if err != nil {
			return err
		}
		var Replace bool
		err = _is.Read_bool(&Replace, 6, true)
		if err != nil {
			return err
		}
		var ExpireTimeSecond int32
		err = _is.Read_int32(&ExpireTimeSecond, 7, true)
		if err != nil {
			return err
		}
		ret, err := _imp.InsertEx(ModuleName, MainIndex, MpValue, Ver, Dirty, Replace, ExpireTimeSecond)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "insertBSEx":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainIndex []int8
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			MainIndex = make([]int8, length, length)
			for i231, e231 := int32(0), length; i231 < e231; i231++ {

				err = _is.Read_int8(&MainIndex[i231], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&MainIndex, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var MpValue map[string]UpdateValueBS
		err, have = _is.SkipTo(codec.MAP, 3, true)
		if err != nil {
			return err
		}

		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}
		MpValue = make(map[string]UpdateValueBS)
		for i232, e232 := int32(0), length; i232 < e232; i232++ {
			var k232 string
			var v232 UpdateValueBS

			err = _is.Read_string(&k232, 0, false)
			if err != nil {
				return err
			}

			err = v232.ReadBlock(_is, 1, false)
			if err != nil {
				return err
			}

			MpValue[k232] = v232
		}
		var Ver int8
		err = _is.Read_int8(&Ver, 4, true)
		if err != nil {
			return err
		}
		var Dirty bool
		err = _is.Read_bool(&Dirty, 5, true)
		if err != nil {
			return err
		}
		var Replace bool
		err = _is.Read_bool(&Replace, 6, true)
		if err != nil {
			return err
		}
		var ExpireTimeSecond int32
		err = _is.Read_int32(&ExpireTimeSecond, 7, true)
		if err != nil {
			return err
		}
		ret, err := _imp.InsertBSEx(ModuleName, MainIndex, MpValue, Ver, Dirty, Replace, ExpireTimeSecond)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "insertBatch":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var VtKeyValue []InsertKeyValue
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtKeyValue = make([]InsertKeyValue, length, length)
			for i233, e233 := int32(0), length; i233 < e233; i233++ {

				err = VtKeyValue[i233].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var MpFailIndexReason map[int32]int32
		ret, err := _imp.InsertBatch(ModuleName, VtKeyValue, &MpFailIndexReason)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.MAP, 3)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(MpFailIndexReason)), 0)
		if err != nil {
			return err
		}
		for k234, v234 := range MpFailIndexReason {

			err = _os.Write_int32(k234, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(v234, 1)
			if err != nil {
				return err
			}
		}
	case "insertBatchBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var VtKeyValue []InsertKeyValueBS
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtKeyValue = make([]InsertKeyValueBS, length, length)
			for i235, e235 := int32(0), length; i235 < e235; i235++ {

				err = VtKeyValue[i235].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var MpFailIndexReason map[int32]int32
		ret, err := _imp.InsertBatchBS(ModuleName, VtKeyValue, &MpFailIndexReason)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.MAP, 3)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(MpFailIndexReason)), 0)
		if err != nil {
			return err
		}
		for k236, v236 := range MpFailIndexReason {

			err = _os.Write_int32(k236, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(v236, 1)
			if err != nil {
				return err
			}
		}
	case "update":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainIndex string
		err = _is.Read_string(&MainIndex, 2, true)
		if err != nil {
			return err
		}
		var MpValue map[string]UpdateValue
		err, have = _is.SkipTo(codec.MAP, 3, true)
		if err != nil {
			return err
		}

		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}
		MpValue = make(map[string]UpdateValue)
		for i237, e237 := int32(0), length; i237 < e237; i237++ {
			var k237 string
			var v237 UpdateValue

			err = _is.Read_string(&k237, 0, false)
			if err != nil {
				return err
			}

			err = v237.ReadBlock(_is, 1, false)
			if err != nil {
				return err
			}

			MpValue[k237] = v237
		}
		var VtCond []Condition
		err, have, ty = _is.SkipToNoCheck(4, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtCond = make([]Condition, length, length)
			for i238, e238 := int32(0), length; i238 < e238; i238++ {

				err = VtCond[i238].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		ret, err := _imp.Update(ModuleName, MainIndex, MpValue, VtCond)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "updateBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainIndex []int8
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			MainIndex = make([]int8, length, length)
			for i239, e239 := int32(0), length; i239 < e239; i239++ {

				err = _is.Read_int8(&MainIndex[i239], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&MainIndex, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var MpValue map[string]UpdateValueBS
		err, have = _is.SkipTo(codec.MAP, 3, true)
		if err != nil {
			return err
		}

		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}
		MpValue = make(map[string]UpdateValueBS)
		for i240, e240 := int32(0), length; i240 < e240; i240++ {
			var k240 string
			var v240 UpdateValueBS

			err = _is.Read_string(&k240, 0, false)
			if err != nil {
				return err
			}

			err = v240.ReadBlock(_is, 1, false)
			if err != nil {
				return err
			}

			MpValue[k240] = v240
		}
		var VtCond []ConditionBS
		err, have, ty = _is.SkipToNoCheck(4, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtCond = make([]ConditionBS, length, length)
			for i241, e241 := int32(0), length; i241 < e241; i241++ {

				err = VtCond[i241].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		ret, err := _imp.UpdateBS(ModuleName, MainIndex, MpValue, VtCond)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "updateEx":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainIndex string
		err = _is.Read_string(&MainIndex, 2, true)
		if err != nil {
			return err
		}
		var MpValue map[string]UpdateValue
		err, have = _is.SkipTo(codec.MAP, 3, true)
		if err != nil {
			return err
		}

		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}
		MpValue = make(map[string]UpdateValue)
		for i242, e242 := int32(0), length; i242 < e242; i242++ {
			var k242 string
			var v242 UpdateValue

			err = _is.Read_string(&k242, 0, false)
			if err != nil {
				return err
			}

			err = v242.ReadBlock(_is, 1, false)
			if err != nil {
				return err
			}

			MpValue[k242] = v242
		}
		var VtCond []Condition
		err, have, ty = _is.SkipToNoCheck(4, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtCond = make([]Condition, length, length)
			for i243, e243 := int32(0), length; i243 < e243; i243++ {

				err = VtCond[i243].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var Ver int8
		err = _is.Read_int8(&Ver, 5, true)
		if err != nil {
			return err
		}
		var Dirty bool
		err = _is.Read_bool(&Dirty, 6, true)
		if err != nil {
			return err
		}
		var ExpireTimeSecond int32
		err = _is.Read_int32(&ExpireTimeSecond, 7, true)
		if err != nil {
			return err
		}
		ret, err := _imp.UpdateEx(ModuleName, MainIndex, MpValue, VtCond, Ver, Dirty, ExpireTimeSecond)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "updateBSEx":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainIndex []int8
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			MainIndex = make([]int8, length, length)
			for i244, e244 := int32(0), length; i244 < e244; i244++ {

				err = _is.Read_int8(&MainIndex[i244], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&MainIndex, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var MpValue map[string]UpdateValueBS
		err, have = _is.SkipTo(codec.MAP, 3, true)
		if err != nil {
			return err
		}

		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}
		MpValue = make(map[string]UpdateValueBS)
		for i245, e245 := int32(0), length; i245 < e245; i245++ {
			var k245 string
			var v245 UpdateValueBS

			err = _is.Read_string(&k245, 0, false)
			if err != nil {
				return err
			}

			err = v245.ReadBlock(_is, 1, false)
			if err != nil {
				return err
			}

			MpValue[k245] = v245
		}
		var VtCond []ConditionBS
		err, have, ty = _is.SkipToNoCheck(4, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtCond = make([]ConditionBS, length, length)
			for i246, e246 := int32(0), length; i246 < e246; i246++ {

				err = VtCond[i246].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var Ver int8
		err = _is.Read_int8(&Ver, 5, true)
		if err != nil {
			return err
		}
		var Dirty bool
		err = _is.Read_bool(&Dirty, 6, true)
		if err != nil {
			return err
		}
		var ExpireTimeSecond int32
		err = _is.Read_int32(&ExpireTimeSecond, 7, true)
		if err != nil {
			return err
		}
		ret, err := _imp.UpdateBSEx(ModuleName, MainIndex, MpValue, VtCond, Ver, Dirty, ExpireTimeSecond)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "updateAtom":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainIndex string
		err = _is.Read_string(&MainIndex, 2, true)
		if err != nil {
			return err
		}
		var MpValue map[string]UpdateValue
		err, have = _is.SkipTo(codec.MAP, 3, true)
		if err != nil {
			return err
		}

		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}
		MpValue = make(map[string]UpdateValue)
		for i247, e247 := int32(0), length; i247 < e247; i247++ {
			var k247 string
			var v247 UpdateValue

			err = _is.Read_string(&k247, 0, false)
			if err != nil {
				return err
			}

			err = v247.ReadBlock(_is, 1, false)
			if err != nil {
				return err
			}

			MpValue[k247] = v247
		}
		var VtCond []Condition
		err, have, ty = _is.SkipToNoCheck(4, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtCond = make([]Condition, length, length)
			for i248, e248 := int32(0), length; i248 < e248; i248++ {

				err = VtCond[i248].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var Dirty bool
		err = _is.Read_bool(&Dirty, 5, true)
		if err != nil {
			return err
		}
		var ExpireTimeSecond int32
		err = _is.Read_int32(&ExpireTimeSecond, 6, true)
		if err != nil {
			return err
		}
		ret, err := _imp.UpdateAtom(ModuleName, MainIndex, MpValue, VtCond, Dirty, ExpireTimeSecond)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "updateBSAtom":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainIndex []int8
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			MainIndex = make([]int8, length, length)
			for i249, e249 := int32(0), length; i249 < e249; i249++ {

				err = _is.Read_int8(&MainIndex[i249], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&MainIndex, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var MpValue map[string]UpdateValueBS
		err, have = _is.SkipTo(codec.MAP, 3, true)
		if err != nil {
			return err
		}

		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}
		MpValue = make(map[string]UpdateValueBS)
		for i250, e250 := int32(0), length; i250 < e250; i250++ {
			var k250 string
			var v250 UpdateValueBS

			err = _is.Read_string(&k250, 0, false)
			if err != nil {
				return err
			}

			err = v250.ReadBlock(_is, 1, false)
			if err != nil {
				return err
			}

			MpValue[k250] = v250
		}
		var VtCond []ConditionBS
		err, have, ty = _is.SkipToNoCheck(4, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtCond = make([]ConditionBS, length, length)
			for i251, e251 := int32(0), length; i251 < e251; i251++ {

				err = VtCond[i251].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var Dirty bool
		err = _is.Read_bool(&Dirty, 5, true)
		if err != nil {
			return err
		}
		var ExpireTimeSecond int32
		err = _is.Read_int32(&ExpireTimeSecond, 6, true)
		if err != nil {
			return err
		}
		ret, err := _imp.UpdateBSAtom(ModuleName, MainIndex, MpValue, VtCond, Dirty, ExpireTimeSecond)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "updateBatch":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var VtKeyValue []UpdateKeyValue
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtKeyValue = make([]UpdateKeyValue, length, length)
			for i252, e252 := int32(0), length; i252 < e252; i252++ {

				err = VtKeyValue[i252].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var MpFailIndexReason map[int32]int32
		ret, err := _imp.UpdateBatch(ModuleName, VtKeyValue, &MpFailIndexReason)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.MAP, 3)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(MpFailIndexReason)), 0)
		if err != nil {
			return err
		}
		for k253, v253 := range MpFailIndexReason {

			err = _os.Write_int32(k253, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(v253, 1)
			if err != nil {
				return err
			}
		}
	case "updateBatchBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var VtKeyValue []UpdateKeyValueBS
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtKeyValue = make([]UpdateKeyValueBS, length, length)
			for i254, e254 := int32(0), length; i254 < e254; i254++ {

				err = VtKeyValue[i254].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var MpFailIndexReason map[int32]int32
		ret, err := _imp.UpdateBatchBS(ModuleName, VtKeyValue, &MpFailIndexReason)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.MAP, 3)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(MpFailIndexReason)), 0)
		if err != nil {
			return err
		}
		for k255, v255 := range MpFailIndexReason {

			err = _os.Write_int32(k255, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(v255, 1)
			if err != nil {
				return err
			}
		}
	case "erase":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainIndex string
		err = _is.Read_string(&MainIndex, 2, true)
		if err != nil {
			return err
		}
		ret, err := _imp.Erase(ModuleName, MainIndex)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "eraseBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainIndex []int8
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			MainIndex = make([]int8, length, length)
			for i256, e256 := int32(0), length; i256 < e256; i256++ {

				err = _is.Read_int8(&MainIndex[i256], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&MainIndex, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		ret, err := _imp.EraseBS(ModuleName, MainIndex)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "del":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainIndex string
		err = _is.Read_string(&MainIndex, 2, true)
		if err != nil {
			return err
		}
		var VtCond []Condition
		err, have, ty = _is.SkipToNoCheck(3, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtCond = make([]Condition, length, length)
			for i257, e257 := int32(0), length; i257 < e257; i257++ {

				err = VtCond[i257].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		ret, err := _imp.Del(ModuleName, MainIndex, VtCond)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "delBatch":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var VtCond []DelCondition
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtCond = make([]DelCondition, length, length)
			for i258, e258 := int32(0), length; i258 < e258; i258++ {

				err = VtCond[i258].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var MRet map[int32]int32
		ret, err := _imp.DelBatch(ModuleName, VtCond, &MRet)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.MAP, 3)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(MRet)), 0)
		if err != nil {
			return err
		}
		for k259, v259 := range MRet {

			err = _os.Write_int32(k259, 0)
			if err != nil {
				return err
			}

			err = _os.Write_int32(v259, 1)
			if err != nil {
				return err
			}
		}
	case "delBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainIndex []int8
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			MainIndex = make([]int8, length, length)
			for i260, e260 := int32(0), length; i260 < e260; i260++ {

				err = _is.Read_int8(&MainIndex[i260], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&MainIndex, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var VtCond []ConditionBS
		err, have, ty = _is.SkipToNoCheck(3, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtCond = make([]ConditionBS, length, length)
			for i261, e261 := int32(0), length; i261 < e261; i261++ {

				err = VtCond[i261].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		ret, err := _imp.DelBS(ModuleName, MainIndex, VtCond)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "getMainKeyCount":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainKey string
		err = _is.Read_string(&MainKey, 2, true)
		if err != nil {
			return err
		}
		ret, err := _imp.GetMainKeyCount(ModuleName, MainKey)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "getMKAllMainKey":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var Index int32
		err = _is.Read_int32(&Index, 2, true)
		if err != nil {
			return err
		}
		var Count int32
		err = _is.Read_int32(&Count, 3, true)
		if err != nil {
			return err
		}
		var MainKey []string
		var IsEnd bool
		ret, err := _imp.GetMKAllMainKey(ModuleName, Index, Count, &MainKey, &IsEnd)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 4)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(MainKey)), 0)
		if err != nil {
			return err
		}
		for _, v := range MainKey {

			err = _os.Write_string(v, 0)
			if err != nil {
				return err
			}
		}

		err = _os.Write_bool(IsEnd, 5)
		if err != nil {
			return err
		}
	case "getRangeList":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainKey string
		err = _is.Read_string(&MainKey, 2, true)
		if err != nil {
			return err
		}
		var Field string
		err = _is.Read_string(&Field, 3, true)
		if err != nil {
			return err
		}
		var IStart int64
		err = _is.Read_int64(&IStart, 4, true)
		if err != nil {
			return err
		}
		var IEnd int64
		err = _is.Read_int64(&IEnd, 5, true)
		if err != nil {
			return err
		}
		var VtData []map[string]string
		ret, err := _imp.GetRangeList(ModuleName, MainKey, Field, IStart, IEnd, &VtData)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 6)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(VtData)), 0)
		if err != nil {
			return err
		}
		for _, v := range VtData {

			err = _os.WriteHead(codec.MAP, 0)
			if err != nil {
				return err
			}
			err = _os.Write_int32(int32(len(v)), 0)
			if err != nil {
				return err
			}
			for k262, v262 := range v {

				err = _os.Write_string(k262, 0)
				if err != nil {
					return err
				}

				err = _os.Write_string(v262, 1)
				if err != nil {
					return err
				}
			}
		}
	case "getRangeListBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainKey []int8
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			MainKey = make([]int8, length, length)
			for i263, e263 := int32(0), length; i263 < e263; i263++ {

				err = _is.Read_int8(&MainKey[i263], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&MainKey, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var Field string
		err = _is.Read_string(&Field, 3, true)
		if err != nil {
			return err
		}
		var IStart int64
		err = _is.Read_int64(&IStart, 4, true)
		if err != nil {
			return err
		}
		var IEnd int64
		err = _is.Read_int64(&IEnd, 5, true)
		if err != nil {
			return err
		}
		var VtData []map[string][]int8
		ret, err := _imp.GetRangeListBS(ModuleName, MainKey, Field, IStart, IEnd, &VtData)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 6)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(VtData)), 0)
		if err != nil {
			return err
		}
		for _, v := range VtData {

			err = _os.WriteHead(codec.MAP, 0)
			if err != nil {
				return err
			}
			err = _os.Write_int32(int32(len(v)), 0)
			if err != nil {
				return err
			}
			for k264, v264 := range v {

				err = _os.Write_string(k264, 0)
				if err != nil {
					return err
				}

				err = _os.WriteHead(codec.SIMPLE_LIST, 1)
				if err != nil {
					return err
				}
				err = _os.WriteHead(codec.BYTE, 0)
				if err != nil {
					return err
				}
				err = _os.Write_int32(int32(len(v264)), 0)
				if err != nil {
					return err
				}
				err = _os.Write_slice_int8(v264)
				if err != nil {
					return err
				}
			}
		}
	case "getList":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainKey string
		err = _is.Read_string(&MainKey, 2, true)
		if err != nil {
			return err
		}
		var Field string
		err = _is.Read_string(&Field, 3, true)
		if err != nil {
			return err
		}
		var IPos int64
		err = _is.Read_int64(&IPos, 4, true)
		if err != nil {
			return err
		}
		var MData map[string]string
		ret, err := _imp.GetList(ModuleName, MainKey, Field, IPos, &MData)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.MAP, 5)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(MData)), 0)
		if err != nil {
			return err
		}
		for k265, v265 := range MData {

			err = _os.Write_string(k265, 0)
			if err != nil {
				return err
			}

			err = _os.Write_string(v265, 1)
			if err != nil {
				return err
			}
		}
	case "getListBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainKey []int8
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			MainKey = make([]int8, length, length)
			for i266, e266 := int32(0), length; i266 < e266; i266++ {

				err = _is.Read_int8(&MainKey[i266], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&MainKey, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var Field string
		err = _is.Read_string(&Field, 3, true)
		if err != nil {
			return err
		}
		var IPos int64
		err = _is.Read_int64(&IPos, 4, true)
		if err != nil {
			return err
		}
		var MData map[string][]int8
		ret, err := _imp.GetListBS(ModuleName, MainKey, Field, IPos, &MData)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.MAP, 5)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(MData)), 0)
		if err != nil {
			return err
		}
		for k267, v267 := range MData {

			err = _os.Write_string(k267, 0)
			if err != nil {
				return err
			}

			err = _os.WriteHead(codec.SIMPLE_LIST, 1)
			if err != nil {
				return err
			}
			err = _os.WriteHead(codec.BYTE, 0)
			if err != nil {
				return err
			}
			err = _os.Write_int32(int32(len(v267)), 0)
			if err != nil {
				return err
			}
			err = _os.Write_slice_int8(v267)
			if err != nil {
				return err
			}
		}
	case "getSet":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainKey string
		err = _is.Read_string(&MainKey, 2, true)
		if err != nil {
			return err
		}
		var Field string
		err = _is.Read_string(&Field, 3, true)
		if err != nil {
			return err
		}
		var VtData []map[string]string
		ret, err := _imp.GetSet(ModuleName, MainKey, Field, &VtData)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 4)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(VtData)), 0)
		if err != nil {
			return err
		}
		for _, v := range VtData {

			err = _os.WriteHead(codec.MAP, 0)
			if err != nil {
				return err
			}
			err = _os.Write_int32(int32(len(v)), 0)
			if err != nil {
				return err
			}
			for k268, v268 := range v {

				err = _os.Write_string(k268, 0)
				if err != nil {
					return err
				}

				err = _os.Write_string(v268, 1)
				if err != nil {
					return err
				}
			}
		}
	case "getSetBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainKey []int8
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			MainKey = make([]int8, length, length)
			for i269, e269 := int32(0), length; i269 < e269; i269++ {

				err = _is.Read_int8(&MainKey[i269], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&MainKey, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var Field string
		err = _is.Read_string(&Field, 3, true)
		if err != nil {
			return err
		}
		var VtData []map[string][]int8
		ret, err := _imp.GetSetBS(ModuleName, MainKey, Field, &VtData)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 4)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(VtData)), 0)
		if err != nil {
			return err
		}
		for _, v := range VtData {

			err = _os.WriteHead(codec.MAP, 0)
			if err != nil {
				return err
			}
			err = _os.Write_int32(int32(len(v)), 0)
			if err != nil {
				return err
			}
			for k270, v270 := range v {

				err = _os.Write_string(k270, 0)
				if err != nil {
					return err
				}

				err = _os.WriteHead(codec.SIMPLE_LIST, 1)
				if err != nil {
					return err
				}
				err = _os.WriteHead(codec.BYTE, 0)
				if err != nil {
					return err
				}
				err = _os.Write_int32(int32(len(v270)), 0)
				if err != nil {
					return err
				}
				err = _os.Write_slice_int8(v270)
				if err != nil {
					return err
				}
			}
		}
	case "getScoreZSet":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainKey string
		err = _is.Read_string(&MainKey, 2, true)
		if err != nil {
			return err
		}
		var VtCond []Condition
		err, have, ty = _is.SkipToNoCheck(3, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtCond = make([]Condition, length, length)
			for i271, e271 := int32(0), length; i271 < e271; i271++ {

				err = VtCond[i271].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var IScore float64
		ret, err := _imp.GetScoreZSet(ModuleName, MainKey, VtCond, &IScore)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.Write_float64(IScore, 4)
		if err != nil {
			return err
		}
	case "getRankZSet":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainKey string
		err = _is.Read_string(&MainKey, 2, true)
		if err != nil {
			return err
		}
		var VtCond []Condition
		err, have, ty = _is.SkipToNoCheck(3, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtCond = make([]Condition, length, length)
			for i272, e272 := int32(0), length; i272 < e272; i272++ {

				err = VtCond[i272].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var BOrder bool
		err = _is.Read_bool(&BOrder, 4, true)
		if err != nil {
			return err
		}
		var IPos int64
		ret, err := _imp.GetRankZSet(ModuleName, MainKey, VtCond, BOrder, &IPos)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.Write_int64(IPos, 5)
		if err != nil {
			return err
		}
	case "getRangeZSet":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainKey string
		err = _is.Read_string(&MainKey, 2, true)
		if err != nil {
			return err
		}
		var Field string
		err = _is.Read_string(&Field, 3, true)
		if err != nil {
			return err
		}
		var IStart int64
		err = _is.Read_int64(&IStart, 4, true)
		if err != nil {
			return err
		}
		var IEnd int64
		err = _is.Read_int64(&IEnd, 5, true)
		if err != nil {
			return err
		}
		var BUp bool
		err = _is.Read_bool(&BUp, 6, true)
		if err != nil {
			return err
		}
		var VtData []map[string]string
		ret, err := _imp.GetRangeZSet(ModuleName, MainKey, Field, IStart, IEnd, BUp, &VtData)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 7)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(VtData)), 0)
		if err != nil {
			return err
		}
		for _, v := range VtData {

			err = _os.WriteHead(codec.MAP, 0)
			if err != nil {
				return err
			}
			err = _os.Write_int32(int32(len(v)), 0)
			if err != nil {
				return err
			}
			for k273, v273 := range v {

				err = _os.Write_string(k273, 0)
				if err != nil {
					return err
				}

				err = _os.Write_string(v273, 1)
				if err != nil {
					return err
				}
			}
		}
	case "selectZSetBatch":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var VtMainKey []string
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtMainKey = make([]string, length, length)
			for i274, e274 := int32(0), length; i274 < e274; i274++ {

				err = _is.Read_string(&VtMainKey[i274], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var Field string
		err = _is.Read_string(&Field, 3, true)
		if err != nil {
			return err
		}
		var VtCond []Condition
		err, have, ty = _is.SkipToNoCheck(4, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtCond = make([]Condition, length, length)
			for i275, e275 := int32(0), length; i275 < e275; i275++ {

				err = VtCond[i275].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var VtData []MainKeyValue
		ret, err := _imp.SelectZSetBatch(ModuleName, VtMainKey, Field, VtCond, &VtData)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 5)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(VtData)), 0)
		if err != nil {
			return err
		}
		for _, v := range VtData {

			err = v.WriteBlock(_os, 0)
			if err != nil {
				return err
			}
		}
	case "getRangeZSetByScore":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainKey string
		err = _is.Read_string(&MainKey, 2, true)
		if err != nil {
			return err
		}
		var Field string
		err = _is.Read_string(&Field, 3, true)
		if err != nil {
			return err
		}
		var IMin float64
		err = _is.Read_float64(&IMin, 4, true)
		if err != nil {
			return err
		}
		var IMax float64
		err = _is.Read_float64(&IMax, 5, true)
		if err != nil {
			return err
		}
		var VtData []map[string]string
		ret, err := _imp.GetRangeZSetByScore(ModuleName, MainKey, Field, IMin, IMax, &VtData)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 6)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(VtData)), 0)
		if err != nil {
			return err
		}
		for _, v := range VtData {

			err = _os.WriteHead(codec.MAP, 0)
			if err != nil {
				return err
			}
			err = _os.Write_int32(int32(len(v)), 0)
			if err != nil {
				return err
			}
			for k276, v276 := range v {

				err = _os.Write_string(k276, 0)
				if err != nil {
					return err
				}

				err = _os.Write_string(v276, 1)
				if err != nil {
					return err
				}
			}
		}
	case "selectZSetBatchBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var VtMainKey [][]int8
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtMainKey = make([][]int8, length, length)
			for i277, e277 := int32(0), length; i277 < e277; i277++ {

				err, have, ty = _is.SkipToNoCheck(0, false)
				if err != nil {
					return err
				}
				if have {
					if ty == codec.LIST {
						err = _is.Read_int32(&length, 0, true)
						if err != nil {
							return err
						}
						VtMainKey[i277] = make([]int8, length, length)
						for i278, e278 := int32(0), length; i278 < e278; i278++ {

							err = _is.Read_int8(&VtMainKey[i277][i278], 0, false)
							if err != nil {
								return err
							}
						}
					} else if ty == codec.SIMPLE_LIST {

						err, _ = _is.SkipTo(codec.BYTE, 0, true)
						if err != nil {
							return err
						}
						err = _is.Read_int32(&length, 0, true)
						if err != nil {
							return err
						}
						err = _is.Read_slice_int8(&VtMainKey[i277], length, true)
						if err != nil {
							return err
						}

					} else {
						err = fmt.Errorf("require vector, but not.")
						if err != nil {
							return err
						}
					}
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var Field string
		err = _is.Read_string(&Field, 3, true)
		if err != nil {
			return err
		}
		var VtCond []ConditionBS
		err, have, ty = _is.SkipToNoCheck(4, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtCond = make([]ConditionBS, length, length)
			for i279, e279 := int32(0), length; i279 < e279; i279++ {

				err = VtCond[i279].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var VtData []MainKeyValueBS
		ret, err := _imp.SelectZSetBatchBS(ModuleName, VtMainKey, Field, VtCond, &VtData)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 5)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(VtData)), 0)
		if err != nil {
			return err
		}
		for _, v := range VtData {

			err = v.WriteBlock(_os, 0)
			if err != nil {
				return err
			}
		}
	case "getScoreZSetBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainKey []int8
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			MainKey = make([]int8, length, length)
			for i280, e280 := int32(0), length; i280 < e280; i280++ {

				err = _is.Read_int8(&MainKey[i280], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&MainKey, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var VtCond []ConditionBS
		err, have, ty = _is.SkipToNoCheck(3, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtCond = make([]ConditionBS, length, length)
			for i281, e281 := int32(0), length; i281 < e281; i281++ {

				err = VtCond[i281].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var IScore float64
		ret, err := _imp.GetScoreZSetBS(ModuleName, MainKey, VtCond, &IScore)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.Write_float64(IScore, 4)
		if err != nil {
			return err
		}
	case "getRankZSetBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainKey []int8
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			MainKey = make([]int8, length, length)
			for i282, e282 := int32(0), length; i282 < e282; i282++ {

				err = _is.Read_int8(&MainKey[i282], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&MainKey, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var VtCond []ConditionBS
		err, have, ty = _is.SkipToNoCheck(3, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtCond = make([]ConditionBS, length, length)
			for i283, e283 := int32(0), length; i283 < e283; i283++ {

				err = VtCond[i283].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var BOrder bool
		err = _is.Read_bool(&BOrder, 4, true)
		if err != nil {
			return err
		}
		var IPos int64
		ret, err := _imp.GetRankZSetBS(ModuleName, MainKey, VtCond, BOrder, &IPos)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.Write_int64(IPos, 5)
		if err != nil {
			return err
		}
	case "getRangeZSetBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainKey []int8
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			MainKey = make([]int8, length, length)
			for i284, e284 := int32(0), length; i284 < e284; i284++ {

				err = _is.Read_int8(&MainKey[i284], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&MainKey, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var Field string
		err = _is.Read_string(&Field, 3, true)
		if err != nil {
			return err
		}
		var IStart int64
		err = _is.Read_int64(&IStart, 4, true)
		if err != nil {
			return err
		}
		var IEnd int64
		err = _is.Read_int64(&IEnd, 5, true)
		if err != nil {
			return err
		}
		var BUp bool
		err = _is.Read_bool(&BUp, 6, true)
		if err != nil {
			return err
		}
		var VtData []map[string][]int8
		ret, err := _imp.GetRangeZSetBS(ModuleName, MainKey, Field, IStart, IEnd, BUp, &VtData)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 7)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(VtData)), 0)
		if err != nil {
			return err
		}
		for _, v := range VtData {

			err = _os.WriteHead(codec.MAP, 0)
			if err != nil {
				return err
			}
			err = _os.Write_int32(int32(len(v)), 0)
			if err != nil {
				return err
			}
			for k285, v285 := range v {

				err = _os.Write_string(k285, 0)
				if err != nil {
					return err
				}

				err = _os.WriteHead(codec.SIMPLE_LIST, 1)
				if err != nil {
					return err
				}
				err = _os.WriteHead(codec.BYTE, 0)
				if err != nil {
					return err
				}
				err = _os.Write_int32(int32(len(v285)), 0)
				if err != nil {
					return err
				}
				err = _os.Write_slice_int8(v285)
				if err != nil {
					return err
				}
			}
		}
	case "getRangeZSetByScoreBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainKey []int8
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			MainKey = make([]int8, length, length)
			for i286, e286 := int32(0), length; i286 < e286; i286++ {

				err = _is.Read_int8(&MainKey[i286], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&MainKey, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var Field string
		err = _is.Read_string(&Field, 3, true)
		if err != nil {
			return err
		}
		var IMin float64
		err = _is.Read_float64(&IMin, 4, true)
		if err != nil {
			return err
		}
		var IMax float64
		err = _is.Read_float64(&IMax, 5, true)
		if err != nil {
			return err
		}
		var VtData []map[string][]int8
		ret, err := _imp.GetRangeZSetByScoreBS(ModuleName, MainKey, Field, IMin, IMax, &VtData)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.LIST, 6)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(VtData)), 0)
		if err != nil {
			return err
		}
		for _, v := range VtData {

			err = _os.WriteHead(codec.MAP, 0)
			if err != nil {
				return err
			}
			err = _os.Write_int32(int32(len(v)), 0)
			if err != nil {
				return err
			}
			for k287, v287 := range v {

				err = _os.Write_string(k287, 0)
				if err != nil {
					return err
				}

				err = _os.WriteHead(codec.SIMPLE_LIST, 1)
				if err != nil {
					return err
				}
				err = _os.WriteHead(codec.BYTE, 0)
				if err != nil {
					return err
				}
				err = _os.Write_int32(int32(len(v287)), 0)
				if err != nil {
					return err
				}
				err = _os.Write_slice_int8(v287)
				if err != nil {
					return err
				}
			}
		}
	case "pushList":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainKey string
		err = _is.Read_string(&MainKey, 2, true)
		if err != nil {
			return err
		}
		var MpValue []InsertKeyValue
		err, have, ty = _is.SkipToNoCheck(3, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			MpValue = make([]InsertKeyValue, length, length)
			for i288, e288 := int32(0), length; i288 < e288; i288++ {

				err = MpValue[i288].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var BHead bool
		err = _is.Read_bool(&BHead, 4, true)
		if err != nil {
			return err
		}
		ret, err := _imp.PushList(ModuleName, MainKey, MpValue, BHead)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "popList":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainKey string
		err = _is.Read_string(&MainKey, 2, true)
		if err != nil {
			return err
		}
		var BHead bool
		err = _is.Read_bool(&BHead, 3, true)
		if err != nil {
			return err
		}
		var Value map[string]string
		ret, err := _imp.PopList(ModuleName, MainKey, BHead, &Value)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.MAP, 4)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(Value)), 0)
		if err != nil {
			return err
		}
		for k289, v289 := range Value {

			err = _os.Write_string(k289, 0)
			if err != nil {
				return err
			}

			err = _os.Write_string(v289, 1)
			if err != nil {
				return err
			}
		}
	case "replaceList":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainKey string
		err = _is.Read_string(&MainKey, 2, true)
		if err != nil {
			return err
		}
		var MpValue map[string]UpdateValue
		err, have = _is.SkipTo(codec.MAP, 3, true)
		if err != nil {
			return err
		}

		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}
		MpValue = make(map[string]UpdateValue)
		for i290, e290 := int32(0), length; i290 < e290; i290++ {
			var k290 string
			var v290 UpdateValue

			err = _is.Read_string(&k290, 0, false)
			if err != nil {
				return err
			}

			err = v290.ReadBlock(_is, 1, false)
			if err != nil {
				return err
			}

			MpValue[k290] = v290
		}
		var IPos int64
		err = _is.Read_int64(&IPos, 4, true)
		if err != nil {
			return err
		}
		var IExpireTime int32
		err = _is.Read_int32(&IExpireTime, 5, true)
		if err != nil {
			return err
		}
		ret, err := _imp.ReplaceList(ModuleName, MainKey, MpValue, IPos, IExpireTime)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "trimList":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainKey string
		err = _is.Read_string(&MainKey, 2, true)
		if err != nil {
			return err
		}
		var IStart int64
		err = _is.Read_int64(&IStart, 3, true)
		if err != nil {
			return err
		}
		var IEnd int64
		err = _is.Read_int64(&IEnd, 4, true)
		if err != nil {
			return err
		}
		ret, err := _imp.TrimList(ModuleName, MainKey, IStart, IEnd)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "remList":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainKey string
		err = _is.Read_string(&MainKey, 2, true)
		if err != nil {
			return err
		}
		var BHead bool
		err = _is.Read_bool(&BHead, 3, true)
		if err != nil {
			return err
		}
		var ICount int64
		err = _is.Read_int64(&ICount, 4, true)
		if err != nil {
			return err
		}
		ret, err := _imp.RemList(ModuleName, MainKey, BHead, ICount)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "pushListBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainKey []int8
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			MainKey = make([]int8, length, length)
			for i291, e291 := int32(0), length; i291 < e291; i291++ {

				err = _is.Read_int8(&MainKey[i291], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&MainKey, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var MpValue []InsertKeyValueBS
		err, have, ty = _is.SkipToNoCheck(3, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			MpValue = make([]InsertKeyValueBS, length, length)
			for i292, e292 := int32(0), length; i292 < e292; i292++ {

				err = MpValue[i292].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var BHead bool
		err = _is.Read_bool(&BHead, 4, true)
		if err != nil {
			return err
		}
		ret, err := _imp.PushListBS(ModuleName, MainKey, MpValue, BHead)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "popListBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainKey []int8
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			MainKey = make([]int8, length, length)
			for i293, e293 := int32(0), length; i293 < e293; i293++ {

				err = _is.Read_int8(&MainKey[i293], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&MainKey, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var BHead bool
		err = _is.Read_bool(&BHead, 3, true)
		if err != nil {
			return err
		}
		var Value map[string][]int8
		ret, err := _imp.PopListBS(ModuleName, MainKey, BHead, &Value)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

		err = _os.WriteHead(codec.MAP, 4)
		if err != nil {
			return err
		}
		err = _os.Write_int32(int32(len(Value)), 0)
		if err != nil {
			return err
		}
		for k294, v294 := range Value {

			err = _os.Write_string(k294, 0)
			if err != nil {
				return err
			}

			err = _os.WriteHead(codec.SIMPLE_LIST, 1)
			if err != nil {
				return err
			}
			err = _os.WriteHead(codec.BYTE, 0)
			if err != nil {
				return err
			}
			err = _os.Write_int32(int32(len(v294)), 0)
			if err != nil {
				return err
			}
			err = _os.Write_slice_int8(v294)
			if err != nil {
				return err
			}
		}
	case "replaceListBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainKey []int8
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			MainKey = make([]int8, length, length)
			for i295, e295 := int32(0), length; i295 < e295; i295++ {

				err = _is.Read_int8(&MainKey[i295], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&MainKey, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var MpValue map[string]UpdateValueBS
		err, have = _is.SkipTo(codec.MAP, 3, true)
		if err != nil {
			return err
		}

		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}
		MpValue = make(map[string]UpdateValueBS)
		for i296, e296 := int32(0), length; i296 < e296; i296++ {
			var k296 string
			var v296 UpdateValueBS

			err = _is.Read_string(&k296, 0, false)
			if err != nil {
				return err
			}

			err = v296.ReadBlock(_is, 1, false)
			if err != nil {
				return err
			}

			MpValue[k296] = v296
		}
		var IPos int64
		err = _is.Read_int64(&IPos, 4, true)
		if err != nil {
			return err
		}
		var IExpireTime int32
		err = _is.Read_int32(&IExpireTime, 5, true)
		if err != nil {
			return err
		}
		ret, err := _imp.ReplaceListBS(ModuleName, MainKey, MpValue, IPos, IExpireTime)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "trimListBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainKey []int8
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			MainKey = make([]int8, length, length)
			for i297, e297 := int32(0), length; i297 < e297; i297++ {

				err = _is.Read_int8(&MainKey[i297], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&MainKey, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var IStart int64
		err = _is.Read_int64(&IStart, 3, true)
		if err != nil {
			return err
		}
		var IEnd int64
		err = _is.Read_int64(&IEnd, 4, true)
		if err != nil {
			return err
		}
		ret, err := _imp.TrimListBS(ModuleName, MainKey, IStart, IEnd)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "remListBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainKey []int8
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			MainKey = make([]int8, length, length)
			for i298, e298 := int32(0), length; i298 < e298; i298++ {

				err = _is.Read_int8(&MainKey[i298], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&MainKey, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var BHead bool
		err = _is.Read_bool(&BHead, 3, true)
		if err != nil {
			return err
		}
		var ICount int64
		err = _is.Read_int64(&ICount, 4, true)
		if err != nil {
			return err
		}
		ret, err := _imp.RemListBS(ModuleName, MainKey, BHead, ICount)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "addSet":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainKey string
		err = _is.Read_string(&MainKey, 2, true)
		if err != nil {
			return err
		}
		var MpValue map[string]UpdateValue
		err, have = _is.SkipTo(codec.MAP, 3, true)
		if err != nil {
			return err
		}

		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}
		MpValue = make(map[string]UpdateValue)
		for i299, e299 := int32(0), length; i299 < e299; i299++ {
			var k299 string
			var v299 UpdateValue

			err = _is.Read_string(&k299, 0, false)
			if err != nil {
				return err
			}

			err = v299.ReadBlock(_is, 1, false)
			if err != nil {
				return err
			}

			MpValue[k299] = v299
		}
		var IExpireTime int32
		err = _is.Read_int32(&IExpireTime, 4, true)
		if err != nil {
			return err
		}
		var IVersion int8
		err = _is.Read_int8(&IVersion, 5, true)
		if err != nil {
			return err
		}
		var BDirty bool
		err = _is.Read_bool(&BDirty, 6, true)
		if err != nil {
			return err
		}
		ret, err := _imp.AddSet(ModuleName, MainKey, MpValue, IExpireTime, IVersion, BDirty)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "delSet":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainKey string
		err = _is.Read_string(&MainKey, 2, true)
		if err != nil {
			return err
		}
		var VtCond []Condition
		err, have, ty = _is.SkipToNoCheck(3, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtCond = make([]Condition, length, length)
			for i300, e300 := int32(0), length; i300 < e300; i300++ {

				err = VtCond[i300].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		ret, err := _imp.DelSet(ModuleName, MainKey, VtCond)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "addSetBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainKey []int8
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			MainKey = make([]int8, length, length)
			for i301, e301 := int32(0), length; i301 < e301; i301++ {

				err = _is.Read_int8(&MainKey[i301], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&MainKey, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var MpValue map[string]UpdateValueBS
		err, have = _is.SkipTo(codec.MAP, 3, true)
		if err != nil {
			return err
		}

		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}
		MpValue = make(map[string]UpdateValueBS)
		for i302, e302 := int32(0), length; i302 < e302; i302++ {
			var k302 string
			var v302 UpdateValueBS

			err = _is.Read_string(&k302, 0, false)
			if err != nil {
				return err
			}

			err = v302.ReadBlock(_is, 1, false)
			if err != nil {
				return err
			}

			MpValue[k302] = v302
		}
		var IExpireTime int32
		err = _is.Read_int32(&IExpireTime, 4, true)
		if err != nil {
			return err
		}
		var IVersion int8
		err = _is.Read_int8(&IVersion, 5, true)
		if err != nil {
			return err
		}
		var BDirty bool
		err = _is.Read_bool(&BDirty, 6, true)
		if err != nil {
			return err
		}
		ret, err := _imp.AddSetBS(ModuleName, MainKey, MpValue, IExpireTime, IVersion, BDirty)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "delSetBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainKey []int8
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			MainKey = make([]int8, length, length)
			for i303, e303 := int32(0), length; i303 < e303; i303++ {

				err = _is.Read_int8(&MainKey[i303], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&MainKey, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var VtCond []ConditionBS
		err, have, ty = _is.SkipToNoCheck(3, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtCond = make([]ConditionBS, length, length)
			for i304, e304 := int32(0), length; i304 < e304; i304++ {

				err = VtCond[i304].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		ret, err := _imp.DelSetBS(ModuleName, MainKey, VtCond)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "addZSet":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainKey string
		err = _is.Read_string(&MainKey, 2, true)
		if err != nil {
			return err
		}
		var MpValue map[string]UpdateValue
		err, have = _is.SkipTo(codec.MAP, 3, true)
		if err != nil {
			return err
		}

		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}
		MpValue = make(map[string]UpdateValue)
		for i305, e305 := int32(0), length; i305 < e305; i305++ {
			var k305 string
			var v305 UpdateValue

			err = _is.Read_string(&k305, 0, false)
			if err != nil {
				return err
			}

			err = v305.ReadBlock(_is, 1, false)
			if err != nil {
				return err
			}

			MpValue[k305] = v305
		}
		var Score float64
		err = _is.Read_float64(&Score, 4, true)
		if err != nil {
			return err
		}
		var IExpireTime int32
		err = _is.Read_int32(&IExpireTime, 5, true)
		if err != nil {
			return err
		}
		var IVersion int8
		err = _is.Read_int8(&IVersion, 6, true)
		if err != nil {
			return err
		}
		var BDirty bool
		err = _is.Read_bool(&BDirty, 7, true)
		if err != nil {
			return err
		}
		ret, err := _imp.AddZSet(ModuleName, MainKey, MpValue, Score, IExpireTime, IVersion, BDirty)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "incScoreZSet":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainKey string
		err = _is.Read_string(&MainKey, 2, true)
		if err != nil {
			return err
		}
		var MpValue map[string]UpdateValue
		err, have = _is.SkipTo(codec.MAP, 3, true)
		if err != nil {
			return err
		}

		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}
		MpValue = make(map[string]UpdateValue)
		for i306, e306 := int32(0), length; i306 < e306; i306++ {
			var k306 string
			var v306 UpdateValue

			err = _is.Read_string(&k306, 0, false)
			if err != nil {
				return err
			}

			err = v306.ReadBlock(_is, 1, false)
			if err != nil {
				return err
			}

			MpValue[k306] = v306
		}
		var Score float64
		err = _is.Read_float64(&Score, 4, true)
		if err != nil {
			return err
		}
		var IExpireTime int32
		err = _is.Read_int32(&IExpireTime, 5, true)
		if err != nil {
			return err
		}
		var IVersion int8
		err = _is.Read_int8(&IVersion, 6, true)
		if err != nil {
			return err
		}
		var BDirty bool
		err = _is.Read_bool(&BDirty, 7, true)
		if err != nil {
			return err
		}
		ret, err := _imp.IncScoreZSet(ModuleName, MainKey, MpValue, Score, IExpireTime, IVersion, BDirty)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "delZSet":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainKey string
		err = _is.Read_string(&MainKey, 2, true)
		if err != nil {
			return err
		}
		var VtCond []Condition
		err, have, ty = _is.SkipToNoCheck(3, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtCond = make([]Condition, length, length)
			for i307, e307 := int32(0), length; i307 < e307; i307++ {

				err = VtCond[i307].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		ret, err := _imp.DelZSet(ModuleName, MainKey, VtCond)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "delRangeZSet":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainKey string
		err = _is.Read_string(&MainKey, 2, true)
		if err != nil {
			return err
		}
		var IMin float64
		err = _is.Read_float64(&IMin, 3, true)
		if err != nil {
			return err
		}
		var IMax float64
		err = _is.Read_float64(&IMax, 4, true)
		if err != nil {
			return err
		}
		ret, err := _imp.DelRangeZSet(ModuleName, MainKey, IMin, IMax)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "addZSetBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainKey []int8
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			MainKey = make([]int8, length, length)
			for i308, e308 := int32(0), length; i308 < e308; i308++ {

				err = _is.Read_int8(&MainKey[i308], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&MainKey, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var MpValue map[string]UpdateValueBS
		err, have = _is.SkipTo(codec.MAP, 3, true)
		if err != nil {
			return err
		}

		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}
		MpValue = make(map[string]UpdateValueBS)
		for i309, e309 := int32(0), length; i309 < e309; i309++ {
			var k309 string
			var v309 UpdateValueBS

			err = _is.Read_string(&k309, 0, false)
			if err != nil {
				return err
			}

			err = v309.ReadBlock(_is, 1, false)
			if err != nil {
				return err
			}

			MpValue[k309] = v309
		}
		var Score float64
		err = _is.Read_float64(&Score, 4, true)
		if err != nil {
			return err
		}
		var IExpireTime int32
		err = _is.Read_int32(&IExpireTime, 5, true)
		if err != nil {
			return err
		}
		var IVersion int8
		err = _is.Read_int8(&IVersion, 6, true)
		if err != nil {
			return err
		}
		var BDirty bool
		err = _is.Read_bool(&BDirty, 7, true)
		if err != nil {
			return err
		}
		ret, err := _imp.AddZSetBS(ModuleName, MainKey, MpValue, Score, IExpireTime, IVersion, BDirty)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "incScoreZSetBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainKey []int8
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			MainKey = make([]int8, length, length)
			for i310, e310 := int32(0), length; i310 < e310; i310++ {

				err = _is.Read_int8(&MainKey[i310], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&MainKey, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var MpValue map[string]UpdateValueBS
		err, have = _is.SkipTo(codec.MAP, 3, true)
		if err != nil {
			return err
		}

		err = _is.Read_int32(&length, 0, true)
		if err != nil {
			return err
		}
		MpValue = make(map[string]UpdateValueBS)
		for i311, e311 := int32(0), length; i311 < e311; i311++ {
			var k311 string
			var v311 UpdateValueBS

			err = _is.Read_string(&k311, 0, false)
			if err != nil {
				return err
			}

			err = v311.ReadBlock(_is, 1, false)
			if err != nil {
				return err
			}

			MpValue[k311] = v311
		}
		var Score float64
		err = _is.Read_float64(&Score, 4, true)
		if err != nil {
			return err
		}
		var IExpireTime int32
		err = _is.Read_int32(&IExpireTime, 5, true)
		if err != nil {
			return err
		}
		var IVersion int8
		err = _is.Read_int8(&IVersion, 6, true)
		if err != nil {
			return err
		}
		var BDirty bool
		err = _is.Read_bool(&BDirty, 7, true)
		if err != nil {
			return err
		}
		ret, err := _imp.IncScoreZSetBS(ModuleName, MainKey, MpValue, Score, IExpireTime, IVersion, BDirty)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "delZSetBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainKey []int8
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			MainKey = make([]int8, length, length)
			for i312, e312 := int32(0), length; i312 < e312; i312++ {

				err = _is.Read_int8(&MainKey[i312], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&MainKey, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var VtCond []ConditionBS
		err, have, ty = _is.SkipToNoCheck(3, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			VtCond = make([]ConditionBS, length, length)
			for i313, e313 := int32(0), length; i313 < e313; i313++ {

				err = VtCond[i313].ReadBlock(_is, 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {
			err = fmt.Errorf("type not support SIMPLE_LIST.")
			if err != nil {
				return err
			}
		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		ret, err := _imp.DelZSetBS(ModuleName, MainKey, VtCond)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "delRangeZSetBS":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var MainKey []int8
		err, have, ty = _is.SkipToNoCheck(2, true)
		if err != nil {
			return err
		}

		if ty == codec.LIST {
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			MainKey = make([]int8, length, length)
			for i314, e314 := int32(0), length; i314 < e314; i314++ {

				err = _is.Read_int8(&MainKey[i314], 0, false)
				if err != nil {
					return err
				}
			}
		} else if ty == codec.SIMPLE_LIST {

			err, _ = _is.SkipTo(codec.BYTE, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_int32(&length, 0, true)
			if err != nil {
				return err
			}
			err = _is.Read_slice_int8(&MainKey, length, true)
			if err != nil {
				return err
			}

		} else {
			err = fmt.Errorf("require vector, but not.")
			if err != nil {
				return err
			}
		}
		var IMin float64
		err = _is.Read_float64(&IMin, 3, true)
		if err != nil {
			return err
		}
		var IMax float64
		err = _is.Read_float64(&IMax, 4, true)
		if err != nil {
			return err
		}
		ret, err := _imp.DelRangeZSetBS(ModuleName, MainKey, IMin, IMax)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}
	case "syncSetBinLog":
		var ModuleName string
		err = _is.Read_string(&ModuleName, 1, true)
		if err != nil {
			return err
		}
		var Set string
		err = _is.Read_string(&Set, 2, true)
		if err != nil {
			return err
		}
		var GroupName string
		err = _is.Read_string(&GroupName, 3, true)
		if err != nil {
			return err
		}
		var LogContent string
		err = _is.Read_string(&LogContent, 4, true)
		if err != nil {
			return err
		}
		var Compress bool
		err = _is.Read_bool(&Compress, 5, true)
		if err != nil {
			return err
		}
		var CacheType CacheType
		err = _is.Read_int32((*int32)(&CacheType), 6, true)
		if err != nil {
			return err
		}
		ret, err := _imp.SyncSetBinLog(ModuleName, Set, GroupName, LogContent, Compress, CacheType)
		if err != nil {
			return err
		}

		err = _os.Write_int32(ret, 0)
		if err != nil {
			return err
		}

	default:
		return fmt.Errorf("func mismatch")
	}
	var status map[string]string
	*resp = requestf.ResponsePacket{
		IVersion:     1,
		CPacketType:  0,
		IRequestId:   req.IRequestId,
		IMessageType: 0,
		IRet:         0,
		SBuffer:      _os.ToBytes(),
		Status:       status,
		SResultDesc:  "",
		Context:      req.Context,
	}
	_ = length
	_ = have
	_ = ty
	return nil
}
